{
  "config": {
    "db.js": "import mongoose from \"mongoose\";\r\n\r\nexport const connectDB = async () => {\r\n  try {\r\n    await mongoose.connect(process.env.MONGO_URI);\r\n    console.log(\"Connected to MongoDB\");\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n};\r\n",
    "env.js": "import dotenv from \"dotenv\";\ndotenv.config();\n\nexport const config = {\n  openai_key: process.env.OPENAI_API_KEY,\n  pinecone_api_key: process.env.PINECONE_API_KEY,\n  pinecone_index_name: process.env.PINECONE_INDEX_NAME || \"cvs\",\n  // pinecone_environment: process.env.PINECONE_ENVIRONMENT, // Optional, for older Pinecone accounts\n  jwt_secret: process.env.JWT_SECRET,\n  jwt_expires_in: process.env.JWT_EXPIRES_IN || \"90d\",\n  jwt_cookie_expires_in: process.env.JWT_COOKIE_EXPIRES_IN || 90,\n  node_env: process.env.NODE_ENV || \"development\",\n  redis: {\n    // Redis Cloud support: Use REDIS_URL if provided (for Redis Cloud)\n    // Format: redis://username:password@host:port or rediss://username:password@host:port (for TLS)\n    url: process.env.REDIS_URL,\n    // Or use individual connection parameters\n    host: process.env.REDIS_HOST || \"localhost\",\n    port: parseInt(process.env.REDIS_PORT || \"6379\", 10),\n    username: process.env.REDIS_USERNAME || undefined,\n    password: process.env.REDIS_PASSWORD || process.env.REDIS_PASSWORD || undefined,\n    // TLS/SSL support for Redis Cloud\n    tls: process.env.REDIS_TLS === \"true\" || process.env.REDIS_URL?.startsWith(\"rediss://\") ? {} : undefined,\n  },\n};\n",
    "redis.js": "import { config } from \"./env.js\";\r\n\r\n/**\r\n * Get Redis connection configuration\r\n * Supports both local Redis and Redis Cloud\r\n */\r\nexport function getRedisConnection() {\r\n  // If REDIS_URL is provided (Redis Cloud), use it\r\n  if (config.redis.url) {\r\n    return {\r\n      url: config.redis.url,\r\n    };\r\n  }\r\n\r\n  // Otherwise, use individual connection parameters\r\n  const connection = {\r\n    host: config.redis.host,\r\n    port: config.redis.port,\r\n  };\r\n\r\n  // Add username if provided (Redis Cloud often requires username)\r\n  if (config.redis.username) {\r\n    connection.username = config.redis.username;\r\n  }\r\n\r\n  // Add password if provided\r\n  if (config.redis.password) {\r\n    connection.password = config.redis.password;\r\n  }\r\n\r\n  // Add TLS if enabled (Redis Cloud often requires TLS)\r\n  if (config.redis.tls) {\r\n    connection.tls = config.redis.tls;\r\n  }\r\n\r\n  return connection;\r\n}\r\n\r\nexport default getRedisConnection;\r\n\r\n"
  },
  "middleware": {
    "auth.middleware.js": "import asyncHandler from \"express-async-handler\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport User from \"../modules/auth/user.model.js\";\r\nimport { AppError } from \"../utils/AppError.js\";\r\nimport { config } from \"../config/env.js\";\r\n\r\n// Protect routes - verify JWT token\r\nexport const protect = asyncHandler(async (req, res, next) => {\r\n  // 1) Getting token and check if it's there\r\n  let token;\r\n  if (\r\n    req.headers.authorization &&\r\n    req.headers.authorization.startsWith(\"Bearer\")\r\n  ) {\r\n    token = req.headers.authorization.split(\" \")[1];\r\n  } else if (req.cookies.jwt) {\r\n    token = req.cookies.jwt;\r\n  }\r\n\r\n  if (!token) {\r\n    return next(\r\n      new AppError(\"You are not logged in! Please log in to get access.\", 401)\r\n    );\r\n  }\r\n\r\n  // 2) Verification token\r\n  let decoded;\r\n  try {\r\n    decoded = jwt.verify(token, config.jwt_secret);\r\n  } catch (err) {\r\n    return next(new AppError(\"Invalid token. Please log in again!\", 401));\r\n  }\r\n\r\n  // 3) Check if user still exists\r\n  const currentUser = await User.findById(decoded.id);\r\n  if (!currentUser) {\r\n    return next(\r\n      new AppError(\r\n        \"The user belonging to this token does no longer exist.\",\r\n        401\r\n      )\r\n    );\r\n  }\r\n\r\n  // 4) Check if user changed password after the token was issued\r\n  if (currentUser.changedPasswordAfter(decoded.iat)) {\r\n    return next(\r\n      new AppError(\"User recently changed password! Please log in again.\", 401)\r\n    );\r\n  }\r\n\r\n  // 5) Check if user is active\r\n  if (!currentUser.active) {\r\n    return next(new AppError(\"Your account has been deactivated.\", 403));\r\n  }\r\n\r\n  // GRANT ACCESS TO PROTECTED ROUTE\r\n  req.user = currentUser;\r\n  next();\r\n});\r\n\r\n// Restrict to certain roles\r\nexport const restrictTo = (...roles) => {\r\n  return (req, res, next) => {\r\n    if (!roles.includes(req.user.role)) {\r\n      return next(\r\n        new AppError(\"You do not have permission to perform this action\", 403)\r\n      );\r\n    }\r\n    next();\r\n  };\r\n};\r\n",
    "errorHandler.middleware.js": "import { AppError } from \"../utils/AppError.js\";\r\n\r\nexport const globalErrorHandler = (err, req, res, next) => {\r\n  err.statusCode = err.statusCode || 500;\r\n  err.status = err.status || \"error\";\r\n\r\n  // Handle Multer errors\r\n  if (err.name === \"MulterError\") {\r\n    if (err.code === \"LIMIT_UNEXPECTED_FILE\") {\r\n      return res.status(400).json({\r\n        status: \"fail\",\r\n        error: \"Unexpected field\",\r\n        message: `Expected field name: 'file'. Received: '${err.field}'`,\r\n      });\r\n    }\r\n    if (err.code === \"LIMIT_FILE_SIZE\") {\r\n      return res.status(400).json({\r\n        status: \"fail\",\r\n        error: \"File too large\",\r\n        message: err.message,\r\n      });\r\n    }\r\n    return res.status(400).json({\r\n      status: \"fail\",\r\n      error: err.message,\r\n    });\r\n  }\r\n\r\n  // Handle operational errors (AppError instances)\r\n  if (err.isOperational) {\r\n    return res.status(err.statusCode).json({\r\n      status: err.status,\r\n      error: err.message,\r\n    });\r\n  }\r\n\r\n  // Handle programming or unknown errors\r\n  console.error(\"ERROR ðŸ’¥\", err);\r\n  return res.status(500).json({\r\n    status: \"error\",\r\n    error: \"Something went wrong!\",\r\n    message: process.env.NODE_ENV === \"development\" ? err.message : undefined,\r\n    stack: process.env.NODE_ENV === \"development\" ? err.stack : undefined,\r\n  });\r\n};\r\n\r\nexport const catchAsync = (fn) => {\r\n  return (req, res, next) => {\r\n    fn(req, res, next).catch(next);\r\n  };\r\n};\r\n\r\n",
    "upload.middleware.js": "import multer from \"multer\";\r\n\r\nexport const uploadMemory = multer({\r\n  storage: multer.memoryStorage(),\r\n  fileFilter: (req, file, cb) => {\r\n    const allowedMimes = [\r\n      \"application/pdf\",\r\n      \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\r\n      \"application/msword\", // .doc files\r\n    ];\r\n\r\n    if (allowedMimes.includes(file.mimetype)) {\r\n      cb(null, true);\r\n    } else {\r\n      cb(new Error(`Invalid file type. Allowed types: PDF, DOCX, DOC`), false);\r\n    }\r\n  },\r\n  limits: {\r\n    fileSize: 10 * 1024 * 1024, // 10MB limit\r\n  },\r\n}).single(\"file\");\r\n"
  },
  "modules": {
    "auth": {
      "auth.controller.js": "import * as authService from \"./auth.service.js\";\r\n\r\nexport const register = authService.register;\r\nexport const login = authService.login;\r\nexport const logout = authService.logout;\r\nexport const getMe = authService.getMe;\r\n",
      "auth.routes.js": "import { Router } from \"express\";\r\nimport * as authController from \"./auth.controller.js\";\r\nimport { protect } from \"../../middleware/auth.middleware.js\";\r\n\r\nconst router = Router();\r\n\r\nrouter.post(\"/register\", authController.register);\r\nrouter.post(\"/login\", authController.login);\r\nrouter.post(\"/logout\", protect, authController.logout);\r\nrouter.get(\"/me\", protect, authController.getMe);\r\n\r\nexport default router;\r\n",
      "auth.service.js": "import User from \"./user.model.js\";\r\nimport { AppError } from \"../../utils/AppError.js\";\r\nimport expressAsyncHandler from \"express-async-handler\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport { config } from \"../../config/env.js\";\r\n\r\n// Helper function to create and send token\r\nconst createSendToken = (user, statusCode, res) => {\r\n  const token = jwt.sign({ id: user._id }, config.jwt_secret, {\r\n    expiresIn: config.jwt_expires_in,\r\n  });\r\n\r\n  const cookieOptions = {\r\n    expires: new Date(\r\n      Date.now() + config.jwt_cookie_expires_in * 24 * 60 * 60 * 1000\r\n    ), // Convert days to milliseconds\r\n    httpOnly: true,\r\n  };\r\n\r\n  // In production, use secure cookies (HTTPS only)\r\n  if (config.node_env === \"production\") {\r\n    cookieOptions.secure = true;\r\n  }\r\n\r\n  // Set cookie\r\n  res.cookie(\"jwt\", token, cookieOptions);\r\n\r\n  // Remove password from output\r\n  user.password = undefined;\r\n\r\n  res.status(statusCode).json({\r\n    status: \"success\",\r\n    token,\r\n    data: {\r\n      user,\r\n    },\r\n  });\r\n};\r\n\r\nexport const register = expressAsyncHandler(async (req, res) => {\r\n  const { name, email, password } = req.body;\r\n\r\n  if (!name || !email || !password) {\r\n    throw new AppError(\"All fields are required\", 400);\r\n  }\r\n\r\n  // Check if user already exists\r\n  const existingUser = await User.findOne({ email });\r\n  if (existingUser) {\r\n    throw new AppError(\"User with this email already exists\", 400);\r\n  }\r\n\r\n  const user = await User.create({ name, email, password });\r\n  createSendToken(user, 201, res);\r\n});\r\n\r\nexport const login = expressAsyncHandler(async (req, res) => {\r\n  const { email, password } = req.body;\r\n\r\n  if (!email || !password) {\r\n    throw new AppError(\"Please provide email and password\", 400);\r\n  }\r\n\r\n  // Find user and include password field\r\n  const user = await User.findOne({ email }).select(\"+password\");\r\n  if (!user || !(await user.comparePassword(password))) {\r\n    throw new AppError(\"Incorrect email or password\", 401);\r\n  }\r\n\r\n  // Check if user is active\r\n  if (!user.active) {\r\n    throw new AppError(\"Your account has been deactivated\", 403);\r\n  }\r\n\r\n  createSendToken(user, 200, res);\r\n});\r\n\r\nexport const logout = expressAsyncHandler(async (req, res) => {\r\n  res.cookie(\"jwt\", \"loggedout\", {\r\n    httpOnly: true,\r\n    expires: new Date(Date.now() + 10 * 1000), // 10 seconds\r\n  });\r\n\r\n  res.status(200).json({\r\n    status: \"success\",\r\n    message: \"Logged out successfully\",\r\n  });\r\n});\r\n\r\n// Get current user (optional helper function)\r\nexport const getMe = expressAsyncHandler(async (req, res) => {\r\n  const user = await User.findById(req.user.id);\r\n  res.status(200).json({\r\n    status: \"success\",\r\n    data: {\r\n      user,\r\n    },\r\n  });\r\n});\r\n",
      "user.model.js": "import mongoose from \"mongoose\";\r\nimport bcrypt from \"bcrypt\";\r\nimport crypto from \"crypto\";\r\n\r\nconst userSchema = new mongoose.Schema(\r\n  {\r\n    name: {\r\n      type: String,\r\n      required: [true, \"Please provide your name\"],\r\n      trim: true,\r\n    },\r\n    email: {\r\n      type: String,\r\n      required: [true, \"Please provide your email\"],\r\n      unique: true,\r\n      lowercase: true,\r\n      trim: true,\r\n      match: [\r\n        /^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/,\r\n        \"Please provide a valid email\",\r\n      ],\r\n    },\r\n    password: {\r\n      type: String,\r\n      required: [true, \"Please provide a password\"],\r\n      minlength: [8, \"Password must be at least 8 characters\"],\r\n      select: false,\r\n    },\r\n    passwordChangedAt: Date,\r\n    passwordResetToken: String,\r\n    passwordResetExpires: Date,\r\n    role: {\r\n      type: String,\r\n      enum: [\"user\", \"admin\"],\r\n      default: \"user\",\r\n    },\r\n    active: {\r\n      type: Boolean,\r\n      default: true,\r\n      //   select: false,\r\n    },\r\n    document: {\r\n      chunksIds: [String],\r\n      fileName: String,\r\n      fileType: String,\r\n      uploadedAt: Date,\r\n      totalChunks: {\r\n        type: Number,\r\n        default: 0,\r\n      },\r\n      atsScore: {\r\n        score: Number, // 0-100\r\n        feedback: {\r\n          strengths: [String],\r\n          weaknesses: [String],\r\n          recommendations: [String],\r\n        },\r\n        breakdown: {\r\n          formatting: Number,\r\n          keywords: Number,\r\n          contact: Number,\r\n          experience: Number,\r\n          education: Number,\r\n          sections: Number,\r\n          atsCompatibility: Number,\r\n        },\r\n        analyzedAt: Date,\r\n      },\r\n      personalInformation: {\r\n        fullName: String,\r\n        email: String,\r\n        phone: String,\r\n        location: String,\r\n        linkedin: String,\r\n        github: String,\r\n        portfolio: String,\r\n        summary: String,\r\n      },\r\n      technicalSkills: [String],\r\n      yearsOfExperience: Number,\r\n      education: [\r\n        {\r\n          degree: String,\r\n          field: String,\r\n          institution: String,\r\n          location: String,\r\n          startDate: String,\r\n          endDate: String,\r\n          gpa: String,\r\n          honors: String,\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  { timestamps: true }\r\n);\r\n\r\n// userSchema.index({ email: 1 });\r\nuserSchema.index({ active: 1 });\r\n\r\n// Hash password before saving\r\nuserSchema.pre(\"save\", async function () {\r\n  // Only run this function if password was actually modified\r\n  if (!this.isModified(\"password\")) return;\r\n\r\n  // Hash the password with cost of 12\r\n  this.password = await bcrypt.hash(this.password, 12);\r\n});\r\n\r\n// Update passwordChangedAt when password is modified\r\nuserSchema.pre(\"save\", function () {\r\n  if (!this.isModified(\"password\") || this.isNew) {\r\n    return;\r\n  }\r\n  this.passwordChangedAt = Date.now() - 1000;\r\n});\r\n\r\nuserSchema.methods.comparePassword = async function (candidatePassword) {\r\n  return await bcrypt.compare(candidatePassword, this.password);\r\n};\r\n\r\nuserSchema.methods.changedPasswordAfter = function (JWTTimestamp) {\r\n  if (this.passwordChangedAt) {\r\n    const changedTimestamp = parseInt(\r\n      this.passwordChangedAt.getTime() / 1000,\r\n      10\r\n    );\r\n    return JWTTimestamp < changedTimestamp;\r\n  }\r\n  return false;\r\n};\r\n\r\nuserSchema.methods.createPasswordResetToken = function () {\r\n  const resetToken = crypto.randomBytes(32).toString(\"hex\");\r\n  this.passwordResetToken = crypto\r\n    .createHash(\"sha256\")\r\n    .update(resetToken)\r\n    .digest(\"hex\");\r\n  this.passwordResetExpires = Date.now() + 10 * 60 * 1000;\r\n  return resetToken;\r\n};\r\n\r\nuserSchema.methods.updateDocument = function (\r\n  chunksIds,\r\n  fileName,\r\n  fileType,\r\n  cvAnalysis = null\r\n) {\r\n  this.document = {\r\n    chunksIds,\r\n    fileName,\r\n    fileType,\r\n    uploadedAt: new Date(),\r\n    totalChunks: chunksIds.length,\r\n    ...(cvAnalysis?.atsScore && { atsScore: cvAnalysis.atsScore }),\r\n    ...(cvAnalysis?.personalInformation && {\r\n      personalInformation: cvAnalysis.personalInformation,\r\n    }),\r\n    ...(cvAnalysis?.technicalSkills && {\r\n      technicalSkills: cvAnalysis.technicalSkills,\r\n    }),\r\n    ...(cvAnalysis?.yearsOfExperience !== undefined && {\r\n      yearsOfExperience: cvAnalysis.yearsOfExperience,\r\n    }),\r\n    ...(cvAnalysis?.education && {\r\n      education: cvAnalysis.education,\r\n    }),\r\n  };\r\n  return this.save();\r\n};\r\n\r\nuserSchema.methods.clearDocument = function () {\r\n  this.document = {\r\n    chunksIds: [],\r\n    fileName: null,\r\n    fileType: null,\r\n    uploadedAt: null,\r\n    totalChunks: 0,\r\n  };\r\n  return this.save();\r\n};\r\n\r\nconst User = mongoose.model(\"User\", userSchema);\r\nexport default User;\r\n"
    },
    "cv-analysis": {
      "cv-analysis.service.js": "import { PDFLoader } from \"@langchain/community/document_loaders/fs/pdf\";\r\nimport { DocxLoader } from \"@langchain/community/document_loaders/fs/docx\";\r\nimport { ChatOpenAI } from \"@langchain/openai\";\r\nimport { AppError } from \"../../utils/AppError.js\";\r\n\r\nconst openai = new ChatOpenAI({\r\n  apiKey: process.env.OPENAI_API_KEY,\r\n  model: \"gpt-4o-mini\",\r\n  temperature: 0,\r\n});\r\n\r\n/**\r\n * Extract full text from CV document\r\n */\r\nasync function extractCVText(fileBuffer, fileType) {\r\n  let loader;\r\n  const mimeType =\r\n    fileType === \"pdf\"\r\n      ? \"application/pdf\"\r\n      : \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\";\r\n  const blob = new Blob([fileBuffer], { type: mimeType });\r\n\r\n  if (fileType === \"pdf\") {\r\n    loader = new PDFLoader(blob);\r\n  } else if (fileType === \"docx\" || fileType === \"doc\") {\r\n    loader = new DocxLoader(blob, { type: fileType });\r\n  } else {\r\n    throw new AppError(`Unsupported file type: ${fileType}`, 400);\r\n  }\r\n\r\n  const docs = await loader.load();\r\n  // Combine all pages/sections into one text\r\n  const fullText = docs.map((doc) => doc.pageContent).join(\"\\n\\n\");\r\n  return fullText;\r\n}\r\n\r\n/**\r\n * Extract personal information, technical skills, and education from CV\r\n */\r\nexport async function extractCVInformation(fileBuffer, fileType) {\r\n  try {\r\n    // Extract text from CV\r\n    const cvText = await extractCVText(fileBuffer, fileType);\r\n\r\n    const extractionPrompt = `You are an expert CV parser. Extract structured information from the following CV.\r\n\r\nCV Content:\r\n${cvText}\r\n\r\nExtract the following information and return it as valid JSON:\r\n\r\n{\r\n  \"personalInformation\": {\r\n    \"fullName\": \"<full name>\",\r\n    \"email\": \"<email address>\",\r\n    \"phone\": \"<phone number>\",\r\n    \"location\": \"<city, country or address>\",\r\n    \"linkedin\": \"<LinkedIn URL if present>\",\r\n    \"github\": \"<GitHub URL if present>\",\r\n    \"portfolio\": \"<Portfolio/website URL if present>\",\r\n    \"summary\": \"<professional summary or objective if present>\"\r\n  },\r\n  \"technicalSkills\": [<array of all technical skills including programming languages, frameworks, databases, tools, cloud platforms, and any other technical skills mentioned>],\r\n  \"yearsOfExperience\": <number representing total years of professional work experience, calculate from all work experience entries>,\r\n  \"education\": [\r\n    {\r\n      \"degree\": \"<degree name>\",\r\n      \"field\": \"<field of study>\",\r\n      \"institution\": \"<university/school name>\",\r\n      \"location\": \"<location>\",\r\n      \"startDate\": \"<start date>\",\r\n      \"endDate\": \"<end date or 'Present' if ongoing>\",\r\n      \"gpa\": \"<GPA if mentioned>\",\r\n      \"honors\": \"<honors or achievements if any>\"\r\n    }\r\n  ]\r\n}\r\n\r\nRules:\r\n- If a field is not found, use null or empty array/string\r\n- For dates, use format: \"MM/YYYY\" or \"YYYY\" or \"Month YYYY\"\r\n- Extract all technical skills mentioned (programming languages, frameworks, databases, tools, cloud platforms, etc.) into a single array\r\n- Calculate yearsOfExperience by summing all professional work experience periods (exclude internships if they are clearly marked as such, but include them if they are substantial professional experience)\r\n- If calculating from dates, use the earliest work start date to the latest work end date (or current date if still working)\r\n- Return yearsOfExperience as a number (can be a decimal like 2.5 for 2 years and 6 months)\r\n- Include all education entries (degrees, certifications, etc.)\r\n- Be accurate and only extract information that is clearly stated\r\n\r\nReturn ONLY valid JSON, no additional text or markdown formatting.`;\r\n\r\n    const response = await openai.invoke(extractionPrompt);\r\n    const responseText = response.content.trim();\r\n\r\n    // Parse JSON response\r\n    let extractedData;\r\n    try {\r\n      const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\r\n      if (jsonMatch) {\r\n        extractedData = JSON.parse(jsonMatch[0]);\r\n      } else {\r\n        extractedData = JSON.parse(responseText);\r\n      }\r\n    } catch (parseError) {\r\n      throw new AppError(\"Failed to parse CV information extraction\", 500);\r\n    }\r\n\r\n    // Combine all technical skills into a single array if they come in categorized format\r\n    let technicalSkills = [];\r\n    if (extractedData.technicalSkills) {\r\n      let skillsData = extractedData.technicalSkills;\r\n\r\n      // If it's a string, try to parse it\r\n      if (typeof skillsData === \"string\") {\r\n        try {\r\n          skillsData = JSON.parse(skillsData);\r\n        } catch (e) {\r\n          skillsData = null;\r\n        }\r\n      }\r\n\r\n      if (skillsData) {\r\n        if (Array.isArray(skillsData)) {\r\n          // Check if it's an array of strings (already flat) or array of objects (categorized)\r\n          if (skillsData.length > 0 && typeof skillsData[0] === \"string\") {\r\n            // Already a single array of strings\r\n            technicalSkills = skillsData.filter(\r\n              (skill) => typeof skill === \"string\"\r\n            );\r\n          } else if (\r\n            skillsData.length > 0 &&\r\n            typeof skillsData[0] === \"object\"\r\n          ) {\r\n            // Array containing categorized object(s) - extract from first object\r\n            const skillsObj = skillsData[0];\r\n            technicalSkills = [\r\n              ...(Array.isArray(skillsObj.programmingLanguages)\r\n                ? skillsObj.programmingLanguages\r\n                : []),\r\n              ...(Array.isArray(skillsObj.frameworks)\r\n                ? skillsObj.frameworks\r\n                : []),\r\n              ...(Array.isArray(skillsObj.databases)\r\n                ? skillsObj.databases\r\n                : []),\r\n              ...(Array.isArray(skillsObj.tools) ? skillsObj.tools : []),\r\n              ...(Array.isArray(skillsObj.cloudPlatforms)\r\n                ? skillsObj.cloudPlatforms\r\n                : []),\r\n              ...(Array.isArray(skillsObj.other) ? skillsObj.other : []),\r\n            ].filter((skill) => typeof skill === \"string\");\r\n            technicalSkills = [...new Set(technicalSkills)];\r\n          } else {\r\n            // Empty array or unexpected format\r\n            technicalSkills = [];\r\n          }\r\n        } else if (\r\n          typeof skillsData === \"object\" &&\r\n          !Array.isArray(skillsData)\r\n        ) {\r\n          // Categorized format - combine all categories into one array\r\n          technicalSkills = [\r\n            ...(Array.isArray(skillsData.programmingLanguages)\r\n              ? skillsData.programmingLanguages\r\n              : []),\r\n            ...(Array.isArray(skillsData.frameworks)\r\n              ? skillsData.frameworks\r\n              : []),\r\n            ...(Array.isArray(skillsData.databases)\r\n              ? skillsData.databases\r\n              : []),\r\n            ...(Array.isArray(skillsData.tools) ? skillsData.tools : []),\r\n            ...(Array.isArray(skillsData.cloudPlatforms)\r\n              ? skillsData.cloudPlatforms\r\n              : []),\r\n            ...(Array.isArray(skillsData.other) ? skillsData.other : []),\r\n          ].filter((skill) => typeof skill === \"string\");\r\n          // Remove duplicates\r\n          technicalSkills = [...new Set(technicalSkills)];\r\n        }\r\n      }\r\n    }\r\n\r\n    // Ensure technicalSkills is always an array of strings\r\n    if (!Array.isArray(technicalSkills)) {\r\n      technicalSkills = [];\r\n    }\r\n\r\n    // Final validation: ensure all items are strings\r\n    technicalSkills = technicalSkills\r\n      .filter(\r\n        (skill) =>\r\n          skill !== null && skill !== undefined && typeof skill === \"string\"\r\n      )\r\n      .map((skill) => String(skill).trim())\r\n      .filter((skill) => skill.length > 0);\r\n\r\n    return {\r\n      personalInformation: extractedData.personalInformation || {},\r\n      technicalSkills: technicalSkills,\r\n      yearsOfExperience: extractedData.yearsOfExperience || null,\r\n      education: extractedData.education || [],\r\n      extractedAt: new Date(),\r\n    };\r\n  } catch (error) {\r\n    if (error instanceof AppError) {\r\n      throw error;\r\n    }\r\n    throw new AppError(\"Failed to extract CV information\", 500);\r\n  }\r\n}\r\n\r\n/**\r\n * Analyze CV and return ATS score\r\n */\r\nexport async function analyzeCV(fileBuffer, fileType) {\r\n  try {\r\n    // Extract text from CV\r\n    const cvText = await extractCVText(fileBuffer, fileType);\r\n\r\n    // Create comprehensive ATS analysis prompt\r\n    const analysisPrompt = `You are an expert ATS (Applicant Tracking System) analyzer. Analyze the following CV and provide a detailed assessment.\r\n\r\nCV Content:\r\n${cvText}\r\n\r\nPlease analyze this CV based on the following ATS criteria:\r\n1. **Formatting & Structure** (20 points): Is the CV well-formatted, easy to parse, and properly structured?\r\n2. **Keywords & Skills** (20 points): Are relevant keywords, technical skills, and industry terms present?\r\n3. **Contact Information** (10 points): Is contact information complete and properly formatted?\r\n4. **Work Experience** (20 points): Are job descriptions clear, with quantifiable achievements?\r\n5. **Education** (10 points): Is education information complete and relevant?\r\n6. **Sections Completeness** (10 points): Are all standard sections (summary, experience, education, skills) present?\r\n7. **ATS Compatibility** (10 points): Is the CV optimized for ATS parsing (no complex formatting, proper headings)?\r\n\r\nProvide your analysis in the following JSON format:\r\n{\r\n  \"score\": <number between 0-100>,\r\n  \"feedback\": {\r\n    \"strengths\": [<array of strengths>],\r\n    \"weaknesses\": [<array of weaknesses>],\r\n    \"recommendations\": [<array of actionable recommendations>]\r\n  },\r\n  \"breakdown\": {\r\n    \"formatting\": <score 0-20>,\r\n    \"keywords\": <score 0-20>,\r\n    \"contact\": <score 0-10>,\r\n    \"experience\": <score 0-20>,\r\n    \"education\": <score 0-10>,\r\n    \"sections\": <score 0-10>,\r\n    \"atsCompatibility\": <score 0-10>\r\n  }\r\n}\r\n\r\nReturn ONLY valid JSON, no additional text.`;\r\n\r\n    // Get structured response from OpenAI\r\n    const response = await openai.invoke(analysisPrompt);\r\n    const responseText = response.content.trim();\r\n\r\n    // Parse JSON response (handle markdown code blocks if present)\r\n    let analysisResult;\r\n    try {\r\n      // Remove markdown code blocks if present\r\n      const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\r\n      if (jsonMatch) {\r\n        analysisResult = JSON.parse(jsonMatch[0]);\r\n      } else {\r\n        analysisResult = JSON.parse(responseText);\r\n      }\r\n    } catch (parseError) {\r\n      throw new AppError(\"Failed to parse CV analysis response\", 500);\r\n    }\r\n\r\n    // After getting ATS score, also extract CV information\r\n    const cvInformation = await extractCVInformation(fileBuffer, fileType);\r\n\r\n    // Combine ATS score with extracted information\r\n    return {\r\n      atsScore: {\r\n        score: Math.round(analysisResult.score || 0),\r\n        feedback: {\r\n          strengths: analysisResult.feedback?.strengths || [],\r\n          weaknesses: analysisResult.feedback?.weaknesses || [],\r\n          recommendations: analysisResult.feedback?.recommendations || [],\r\n        },\r\n        breakdown: analysisResult.breakdown || {},\r\n        analyzedAt: new Date(),\r\n      },\r\n      personalInformation: cvInformation.personalInformation,\r\n      technicalSkills: cvInformation.technicalSkills,\r\n      yearsOfExperience: cvInformation.yearsOfExperience,\r\n      education: cvInformation.education,\r\n    };\r\n  } catch (error) {\r\n    if (error instanceof AppError) {\r\n      throw error;\r\n    }\r\n    throw new AppError(\"Failed to analyze CV\", 500);\r\n  }\r\n}\r\n"
    },
    "interview": {
      "interview-session.model.js": "import mongoose from \"mongoose\";\n\nconst { Schema, Types } = mongoose;\n\nconst messageSchema = new Schema(\n  {\n    role: {\n      type: String,\n      enum: [\"user\", \"interviewer\", \"system\"],\n      required: true,\n    },\n    content: {\n      type: String,\n      required: true,\n    },\n    timestamp: {\n      type: Date,\n      default: Date.now,\n    },\n  },\n  { _id: false }\n);\n\nconst interviewSessionSchema = new Schema(\n  {\n    userId: { type: Types.ObjectId, ref: \"User\", required: true },\n\n    status: {\n      type: String,\n      enum: [\"idle\", \"started\", \"active\", \"completed\"],\n      default: \"idle\",\n    },\n\n    state: {\n      type: String,\n      enum: [\n        \"STARTED\",\n        \"ASKING_QUESTION\",\n        \"WAITING_FOR_ANSWER\",\n        \"PROCESSING_ANSWER\",\n        \"COMPLETED\",\n      ],\n    },\n\n    language: {\n      type: String,\n      enum: [\"en\", \"ar\"],\n      default: \"en\",\n    },\n\n    difficulty: {\n      type: String,\n      enum: [\"junior\", \"mid\", \"senior\"],\n    },\n\n    voice: {\n      type: String,\n      default: \"alloy\",\n    },\n\n    interviewerStyle: {\n      type: String,\n      enum: [\"technical\", \"friendly\", \"formal\"],\n      default: \"technical\",\n    },\n\n    currentQuestionIndex: {\n      type: Number,\n      default: 0,\n    },\n\n    questions: [\n      {\n        text: String,\n        category: String,\n        difficulty: String,\n        askedAt: Date,\n        answer: String,\n        evaluation: {\n          score: Number,\n          feedback: String,\n          evaluatedAt: Date,\n        },\n      },\n    ],\n\n    questionsGeneratingAt: {\n      type: Date,\n      // Temporary lock field to prevent concurrent question generation\n    },\n\n    transcript: [messageSchema],\n\n    startedAt: Date,\n    endedAt: Date,\n  },\n  { timestamps: true }\n);\n\n// Indexes\ninterviewSessionSchema.index({ userId: 1, createdAt: -1 });\ninterviewSessionSchema.index({ status: 1 });\n\nconst InterviewSession = mongoose.model(\n  \"InterviewSession\",\n  interviewSessionSchema\n);\n\nexport default InterviewSession;\n",
      "interview.cache.js": "import Redis from \"ioredis\";\r\nimport { getRedisConnection } from \"../../config/redis.js\";\r\nimport { CACHE_TTL } from \"./interview.constants.js\";\r\nimport logger from \"../../utils/logger.js\";\r\n\r\n/**\r\n * Redis-based Session Cache for Interview\r\n * Caches active sessions to reduce database queries\r\n */\r\n\r\nlet redisClient = null;\r\n\r\n/**\r\n * Initialize Redis client\r\n */\r\nfunction getRedisClient() {\r\n  if (!redisClient) {\r\n    const connection = getRedisConnection();\r\n    redisClient = connection.url\r\n      ? new Redis(connection.url)\r\n      : new Redis(connection);\r\n    \r\n    redisClient.on(\"error\", (err) => {\r\n      logger.error({ err }, \"Redis cache connection error\");\r\n    });\r\n  }\r\n  return redisClient;\r\n}\r\n\r\n/**\r\n * Cache session data\r\n * @param {string} sessionId - Session ID\r\n * @param {Object} sessionData - Session data to cache\r\n * @param {number} ttl - Time to live in seconds (default from CACHE_TTL.SESSION)\r\n * @returns {Promise<void>}\r\n */\r\nexport async function cacheSession(sessionId, sessionData, ttl = CACHE_TTL.SESSION) {\r\n  try {\r\n    const client = getRedisClient();\r\n    const key = `session:${sessionId}`;\r\n    await client.setex(\r\n      key,\r\n      ttl,\r\n      JSON.stringify(sessionData)\r\n    );\r\n  } catch (error) {\r\n    logger.error({ error, sessionId }, \"Failed to cache session\");\r\n  }\r\n}\r\n\r\n/**\r\n * Get cached session data\r\n * @param {string} sessionId - Session ID\r\n * @returns {Promise<Object|null>} Cached session data or null\r\n */\r\nexport async function getCachedSession(sessionId) {\r\n  try {\r\n    const client = getRedisClient();\r\n    const key = `session:${sessionId}`;\r\n    const data = await client.get(key);\r\n    \r\n    if (!data) {\r\n      return null;\r\n    }\r\n    \r\n    return JSON.parse(data);\r\n  } catch (error) {\r\n    logger.error({ error, sessionId }, \"Failed to get cached session\");\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Invalidate session cache\r\n * @param {string} sessionId - Session ID\r\n * @returns {Promise<void>}\r\n */\r\nexport async function invalidateSessionCache(sessionId) {\r\n  try {\r\n    const client = getRedisClient();\r\n    const key = `session:${sessionId}`;\r\n    await client.del(key);\r\n  } catch (error) {\r\n    logger.error({ error, sessionId }, \"Failed to invalidate session cache\");\r\n  }\r\n}\r\n\r\n/**\r\n * Update cached session (partial update)\r\n * @param {string} sessionId - Session ID\r\n * @param {Object} updates - Partial session data to update\r\n * @returns {Promise<void>}\r\n */\r\nexport async function updateCachedSession(sessionId, updates) {\r\n  try {\r\n    const cached = await getCachedSession(sessionId);\r\n    if (cached) {\r\n      const updated = { ...cached, ...updates };\r\n      await cacheSession(sessionId, updated);\r\n    }\r\n  } catch (error) {\r\n    logger.error({ error, sessionId }, \"Failed to update cached session\");\r\n  }\r\n}\r\n\r\n/**\r\n * Cache user data\r\n * @param {string} userId - User ID\r\n * @param {Object} userData - User data to cache\r\n * @param {number} ttl - Time to live in seconds (default from CACHE_TTL.USER_DATA)\r\n * @returns {Promise<void>}\r\n */\r\nexport async function cacheUserData(userId, userData, ttl = CACHE_TTL.USER_DATA) {\r\n  try {\r\n    const client = getRedisClient();\r\n    const key = `user:${userId}`;\r\n    await client.setex(\r\n      key,\r\n      ttl,\r\n      JSON.stringify(userData)\r\n    );\r\n  } catch (error) {\r\n    logger.error({ error, userId }, \"Failed to cache user data\");\r\n  }\r\n}\r\n\r\n/**\r\n * Get cached user data\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Object|null>} Cached user data or null\r\n */\r\nexport async function getCachedUserData(userId) {\r\n  try {\r\n    const client = getRedisClient();\r\n    const key = `user:${userId}`;\r\n    const data = await client.get(key);\r\n    \r\n    if (!data) {\r\n      return null;\r\n    }\r\n    \r\n    return JSON.parse(data);\r\n  } catch (error) {\r\n    logger.error({ error, userId }, \"Failed to get cached user data\");\r\n    return null;\r\n  }\r\n}\r\n\r\n",
      "interview.constants.js": "/**\n * Socket Interview Constants\n * Centralized constants for interview socket events, states, and limits\n */\n\n// Socket Event Names\nexport const SOCKET_EVENTS = {\n  // Client to Server\n  ANSWER: \"interview:answer\",\n  AUDIO_ANSWER: \"interview:audio-answer\",\n  PING: \"interview:ping\",\n  \n  // Server to Client\n  MESSAGE: \"interview:message\",\n  QUESTION: \"interview:question\",\n  TTS: \"interview:tts\",\n  EVALUATION: \"interview:evaluation\",\n  TRANSCRIPTION: \"interview:transcription\",\n  ENDED: \"interview:ended\",\n  FINAL_FEEDBACK: \"interview:final-feedback\",\n  ERROR: \"error\",\n};\n\n// Session States\nexport const SESSION_STATES = {\n  STARTED: \"STARTED\",\n  ASKING_QUESTION: \"ASKING_QUESTION\",\n  WAITING_FOR_ANSWER: \"WAITING_FOR_ANSWER\",\n  PROCESSING_ANSWER: \"PROCESSING_ANSWER\",\n  COMPLETED: \"COMPLETED\",\n};\n\n// Session Status\nexport const SESSION_STATUS = {\n  IDLE: \"idle\",\n  STARTED: \"started\",\n  ACTIVE: \"active\",\n  COMPLETED: \"completed\",\n};\n\n// FSM Events\nexport const FSM_EVENTS = {\n  START: \"START\",\n  ANSWER: \"ANSWER\",\n  NEXT_QUESTION: \"NEXT_QUESTION\",\n  END: \"END\",\n};\n\n// Validation Limits\nexport const VALIDATION_LIMITS = {\n  MAX_TEXT_LENGTH: 5000,\n  MAX_AUDIO_SIZE: 10 * 1024 * 1024, // 10MB\n  MAX_AUDIO_DURATION: 300, // 5 minutes in seconds\n  MIN_TEXT_LENGTH: 1,\n};\n\n// Valid Audio MIME Types\nexport const VALID_AUDIO_TYPES = [\n  \"audio/webm\",\n  \"audio/wav\",\n  \"audio/mp3\",\n  \"audio/mpeg\",\n  \"audio/ogg\",\n  \"audio/m4a\",\n];\n\n// Timeout Values (in milliseconds)\nexport const TIMEOUTS = {\n  ANSWER_TIMEOUT: 5 * 60 * 1000, // 5 minutes\n  SESSION_INACTIVITY_TIMEOUT: 30 * 60 * 1000, // 30 minutes\n  TTS_GENERATION_TIMEOUT: 30 * 1000, // 30 seconds\n  STT_PROCESSING_TIMEOUT: 60 * 1000, // 60 seconds\n  EVALUATION_TIMEOUT: 60 * 1000, // 60 seconds\n};\n\n// Rate Limiting\nexport const RATE_LIMITS = {\n  ANSWERS_PER_MINUTE: 10,\n  AUDIO_PER_MINUTE: 5,\n  QUESTIONS_PER_MINUTE: 2,\n};\n\n// Cache TTL (in seconds)\nexport const CACHE_TTL = {\n  SESSION: 60 * 60, // 1 hour\n  USER_DATA: 30 * 60, // 30 minutes\n};\n\n// Retry Configuration\nexport const RETRY_CONFIG = {\n  MAX_RETRIES: 3,\n  RETRY_DELAY: 1000, // 1 second\n  RETRY_BACKOFF: 2, // exponential backoff multiplier\n};\n\n// Welcome Messages\nexport const WELCOME_MESSAGES = {\n  en: \"Welcome. Let's start the interview.\",\n  ar: \"Ø£Ù‡Ù„Ø§Ù‹ØŒ Ø®Ù„Ù‘ÙŠÙ†Ø§ Ù†Ø¨Ø¯Ø£ Ø§Ù„Ø§Ù†ØªØ±ÙÙŠÙˆ.\",\n};\n\n// Interview Limits\nexport const INTERVIEW_LIMITS = {\n  MAX_QUESTIONS: 8, // Maximum 8 questions per interview\n  MIN_QUESTIONS: 5, // Minimum 5 questions before allowing termination\n};\n\n",
      "interview.controller.js": "import asyncHandler from \"express-async-handler\";\r\nimport {\r\n  generateInterviewQuestions,\r\n  startInterviewSession,\r\n} from \"./interview.service.js\";\r\nimport { AppError } from \"../../utils/AppError.js\";\r\nimport InterviewSession from \"./interview-session.model.js\";\r\n\r\nexport const generateQuestions = asyncHandler(async (req, res) => {\r\n  // Get userId from req.user (set by auth middleware)\r\n  const userId = req.user?._id || req.user?.id;\r\n  if (!userId) {\r\n    throw new AppError(\"User not authenticated\", 401);\r\n  }\r\n\r\n  const questions = await generateInterviewQuestions(userId);\r\n\r\n  res.json({\r\n    status: \"success\",\r\n    data: {\r\n      questions,\r\n    },\r\n  });\r\n});\r\n\r\n/**\r\n * Get all interview sessions for the authenticated user\r\n */\r\nexport const getUserSessions = asyncHandler(async (req, res) => {\r\n  const userId = req.user?._id || req.user?.id;\r\n  if (!userId) {\r\n    throw new AppError(\"User not authenticated\", 401);\r\n  }\r\n\r\n  const sessions = await InterviewSession.find({ userId })\r\n    .sort({ createdAt: -1 })\r\n    .select(\"-transcript\")\r\n    .lean();\r\n\r\n  res.json({\r\n    status: \"success\",\r\n    results: sessions.length,\r\n    data: {\r\n      sessions,\r\n    },\r\n  });\r\n});\r\n\r\n/**\r\n * Get a specific interview session by ID\r\n */\r\nexport const getSessionById = asyncHandler(async (req, res) => {\r\n  const userId = req.user?._id || req.user?.id;\r\n  if (!userId) {\r\n    throw new AppError(\"User not authenticated\", 401);\r\n  }\r\n\r\n  const { sessionId } = req.params;\r\n\r\n  const session = await InterviewSession.findOne({\r\n    _id: sessionId,\r\n    userId,\r\n  });\r\n\r\n  if (!session) {\r\n    throw new AppError(\"Interview session not found\", 404);\r\n  }\r\n\r\n  res.json({\r\n    status: \"success\",\r\n    data: {\r\n      session,\r\n    },\r\n  });\r\n});\r\n\r\n/**\r\n * Delete an interview session\r\n */\r\nexport const deleteSession = asyncHandler(async (req, res) => {\r\n  const userId = req.user?._id || req.user?.id;\r\n  if (!userId) {\r\n    throw new AppError(\"User not authenticated\", 401);\r\n  }\r\n\r\n  const { sessionId } = req.params;\r\n\r\n  const session = await InterviewSession.findOneAndDelete({\r\n    _id: sessionId,\r\n    userId,\r\n  });\r\n\r\n  if (!session) {\r\n    throw new AppError(\"Interview session not found\", 404);\r\n  }\r\n\r\n  res.json({\r\n    status: \"success\",\r\n    message: \"Interview session deleted successfully\",\r\n  });\r\n});\r\n\r\nexport const startInterview = asyncHandler(async (req, res) => {\r\n  const userId = req.user._id;\r\n\r\n  const { language, interviewerStyle, voice } = req.body;\r\n\r\n  const session = await startInterviewSession({\r\n    userId,\r\n    language,\r\n    interviewerStyle,\r\n    voice,\r\n  });\r\n\r\n  res.status(201).json({\r\n    status: \"success\",\r\n    data: {\r\n      sessionId: session._id,\r\n      language: session.language,\r\n      interviewerStyle: session.interviewerStyle,\r\n      voice: session.voice,\r\n      status: session.status,\r\n      startedAt: session.startedAt,\r\n    },\r\n  });\r\n});\r\n",
      "interview.evaluation.js": "import { ChatOpenAI } from \"@langchain/openai\";\r\nimport { RETRY_CONFIG, TIMEOUTS } from \"./interview.constants.js\";\r\nimport logger from \"../../utils/logger.js\";\r\n\r\nconst llm = new ChatOpenAI({\r\n  model: \"gpt-4o-mini\",\r\n  temperature: 0,\r\n  apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\n/**\r\n * Retry helper with exponential backoff\r\n */\r\nasync function retryWithBackoff(fn, maxRetries = RETRY_CONFIG.MAX_RETRIES) {\r\n  let lastError;\r\n  \r\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n    try {\r\n      return await fn();\r\n    } catch (error) {\r\n      lastError = error;\r\n      \r\n      if (attempt < maxRetries) {\r\n        const delay = RETRY_CONFIG.RETRY_DELAY * Math.pow(RETRY_CONFIG.RETRY_BACKOFF, attempt);\r\n        logger.warn({ attempt: attempt + 1, delay, error: error.message }, \"Retrying evaluation\");\r\n        await new Promise((resolve) => setTimeout(resolve, delay));\r\n      }\r\n    }\r\n  }\r\n  \r\n  throw lastError;\r\n}\r\n\r\nexport async function evaluateAnswer({\r\n  question,\r\n  answer,\r\n  difficulty,\r\n  language,\r\n}) {\r\n  const log = logger.child({ question: question.substring(0, 50), difficulty, language });\r\n  log.debug(\"Evaluating answer\");\r\n\r\n  const prompt = `\r\nYou are a professional technical interviewer.\r\n\r\nLanguage: ${language}\r\nDifficulty level: ${difficulty}\r\n\r\nQuestion:\r\n\"${question}\"\r\n\r\nCandidate Answer:\r\n\"${answer}\"\r\n\r\nEvaluate the answer and return ONLY valid JSON in this format:\r\n\r\n{\r\n  \"score\": number (0-10),\r\n  \"feedback\": \"short constructive feedback\",\r\n  \"followUp\": \"a short next interview question OR null if not needed\"\r\n}\r\n`;\r\n\r\n  try {\r\n    // Set timeout for evaluation\r\n    const timeoutPromise = new Promise((_, reject) => {\r\n      setTimeout(\r\n        () => reject(new Error(\"Evaluation timeout\")),\r\n        TIMEOUTS.EVALUATION_TIMEOUT\r\n      );\r\n    });\r\n\r\n    // Retry with exponential backoff\r\n    const evaluationPromise = retryWithBackoff(async () => {\r\n      const res = await llm.invoke(prompt);\r\n      const text = res.content.trim();\r\n\r\n      // Parse JSON response\r\n      let json;\r\n      try {\r\n        const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\r\n        if (jsonMatch) {\r\n          json = JSON.parse(jsonMatch[0]);\r\n        } else {\r\n          throw new Error(\"No JSON found in response\");\r\n        }\r\n      } catch (parseError) {\r\n        log.error({ parseError, text: text.substring(0, 200) }, \"Failed to parse evaluation response\");\r\n        throw new Error(\"Invalid JSON response from LLM\");\r\n      }\r\n\r\n      // Validate response structure\r\n      if (typeof json.score !== \"number\" || json.score < 0 || json.score > 10) {\r\n        throw new Error(\"Invalid score in evaluation response\");\r\n      }\r\n\r\n      if (!json.feedback || typeof json.feedback !== \"string\") {\r\n        throw new Error(\"Invalid feedback in evaluation response\");\r\n      }\r\n\r\n      return {\r\n        score: Math.max(0, Math.min(10, Math.round(json.score))), // Clamp score to 0-10\r\n        feedback: json.feedback.trim(),\r\n        followUp: json.followUp && typeof json.followUp === \"string\" ? json.followUp.trim() : null,\r\n      };\r\n    });\r\n\r\n    const result = await Promise.race([evaluationPromise, timeoutPromise]);\r\n    log.debug({ score: result.score, hasFollowUp: !!result.followUp }, \"Answer evaluated\");\r\n    return result;\r\n  } catch (error) {\r\n    log.error({ error }, \"Failed to evaluate answer\");\r\n    \r\n    // Return fallback evaluation on error\r\n    return {\r\n      score: 5, // Neutral score\r\n      feedback: language === \"ar\" \r\n        ? \"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.\"\r\n        : \"An error occurred while evaluating the answer. Please try again.\",\r\n      followUp: null,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check if user wants to end the interview using LLM intent detection\r\n */\r\nexport async function checkTerminationIntent(answer, language = \"en\") {\r\n  const log = logger.child({ answer: answer.substring(0, 50), language });\r\n  log.debug(\"Checking termination intent\");\r\n\r\n  const prompt = `\r\nYou are an AI assistant analyzing user responses during an interview session.\r\n\r\nLanguage: ${language}\r\n\r\nUser's response:\r\n\"${answer}\"\r\n\r\nAnalyze this response and determine if the user wants to END or TERMINATE the interview session.\r\n\r\nThe user might express this in various ways:\r\n- Directly saying they want to finish/end/stop\r\n- Indicating they're done or satisfied\r\n- Asking to conclude the interview\r\n- Expressing that they've answered enough questions\r\n- Any other way that clearly indicates they want to end the session\r\n\r\nIMPORTANT: Only return true if the user CLEARLY wants to end the interview. \r\nIf the response is just an answer to a question (even if it mentions being done with a specific topic), return false.\r\n\r\nReturn ONLY valid JSON in this format:\r\n{\r\n  \"shouldTerminate\": boolean,\r\n  \"confidence\": number (0-1),\r\n  \"reason\": \"brief explanation of why\"\r\n}\r\n\r\nReturn ONLY valid JSON, no additional text or markdown formatting.`;\r\n\r\n  try {\r\n    const timeoutPromise = new Promise((_, reject) => {\r\n      setTimeout(\r\n        () => reject(new Error(\"Intent detection timeout\")),\r\n        10 * 1000 // 10 seconds timeout for intent detection\r\n      );\r\n    });\r\n\r\n    const intentPromise = retryWithBackoff(async () => {\r\n      const res = await llm.invoke(prompt);\r\n      const text = res.content.trim();\r\n\r\n      // Parse JSON response\r\n      let json;\r\n      try {\r\n        const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\r\n        if (jsonMatch) {\r\n          json = JSON.parse(jsonMatch[0]);\r\n        } else {\r\n          throw new Error(\"No JSON found in response\");\r\n        }\r\n      } catch (parseError) {\r\n        log.error({ parseError, text: text.substring(0, 200) }, \"Failed to parse intent response\");\r\n        throw new Error(\"Invalid JSON response from LLM\");\r\n      }\r\n\r\n      // Validate response structure\r\n      if (typeof json.shouldTerminate !== \"boolean\") {\r\n        throw new Error(\"Invalid shouldTerminate in intent response\");\r\n      }\r\n\r\n      return {\r\n        shouldTerminate: json.shouldTerminate,\r\n        confidence: typeof json.confidence === \"number\" \r\n          ? Math.max(0, Math.min(1, json.confidence)) \r\n          : json.shouldTerminate ? 0.8 : 0.2,\r\n        reason: json.reason || (json.shouldTerminate ? \"User wants to end interview\" : \"User is continuing\"),\r\n      };\r\n    });\r\n\r\n    const result = await Promise.race([intentPromise, timeoutPromise]);\r\n    log.debug({ \r\n      shouldTerminate: result.shouldTerminate, \r\n      confidence: result.confidence \r\n    }, \"Intent detected\");\r\n    \r\n    return result;\r\n  } catch (error) {\r\n    log.error({ error }, \"Failed to detect termination intent\");\r\n    \r\n    // On error, default to false (don't terminate) to be safe\r\n    return {\r\n      shouldTerminate: false,\r\n      confidence: 0,\r\n      reason: \"Error detecting intent, defaulting to continue\",\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Generate comprehensive feedback for the entire interview\r\n */\r\nexport async function generateOverallFeedback(session, userId, language = \"en\") {\r\n  const log = logger.child({ sessionId: session._id, language });\r\n  log.debug(\"Generating overall interview feedback\");\r\n\r\n  try {\r\n    // Get user info\r\n    const User = (await import(\"../auth/user.model.js\")).default;\r\n    const user = await User.findById(userId);\r\n    const userName = user?.document?.personalInformation?.fullName || \"Candidate\";\r\n\r\n    // Build conversation summary\r\n    const questions = session.questions || [];\r\n    const answers = session.transcript?.filter(msg => msg.role === \"user\") || [];\r\n    \r\n    // Calculate statistics\r\n    const totalQuestions = questions.length;\r\n    const totalAnswers = answers.length;\r\n    const evaluations = questions.filter(q => q.evaluation).map(q => q.evaluation);\r\n    const avgScore = evaluations.length > 0\r\n      ? evaluations.reduce((sum, evaluation) => sum + (evaluation.score || 0), 0) / evaluations.length\r\n      : null;\r\n\r\n    // Build Q&A summary\r\n    const qaSummary = questions\r\n      .map((q, idx) => {\r\n        const answer = answers[idx];\r\n        const evaluation = q.evaluation;\r\n        return `Q${idx + 1}: ${q.text}\r\nA${idx + 1}: ${answer?.content || \"No answer\"}\r\nScore: ${evaluation?.score || \"N/A\"}/10\r\n${evaluation?.feedback ? `Feedback: ${evaluation.feedback}` : \"\"}`;\r\n      })\r\n      .join(\"\\n\\n\");\r\n\r\n    const prompt = `\r\nYou are a professional technical interviewer providing comprehensive feedback after completing an interview.\r\n\r\nCandidate: ${userName}\r\nLanguage: ${language}\r\nTotal Questions: ${totalQuestions}\r\nTotal Answers: ${totalAnswers}\r\n${avgScore !== null ? `Average Score: ${avgScore.toFixed(1)}/10` : \"\"}\r\n\r\nInterview Summary:\r\n${qaSummary}\r\n\r\nYour task:\r\n1. Provide a comprehensive overall assessment of the candidate's performance\r\n2. Highlight strengths and areas for improvement\r\n3. Give specific examples from their answers\r\n4. Provide actionable recommendations\r\n5. Be constructive and encouraging\r\n6. Keep it professional and detailed (4-6 paragraphs)\r\n\r\nReturn ONLY valid JSON in this format:\r\n{\r\n  \"overallScore\": number (0-10),\r\n  \"summary\": \"overall performance summary (2-3 sentences)\",\r\n  \"strengths\": [\"strength1\", \"strength2\", \"strength3\"],\r\n  \"weaknesses\": [\"weakness1\", \"weakness2\"],\r\n  \"recommendations\": [\"recommendation1\", \"recommendation2\", \"recommendation3\"],\r\n  \"detailedFeedback\": \"comprehensive detailed feedback (4-6 paragraphs)\"\r\n}\r\n\r\nReturn ONLY valid JSON, no additional text or markdown formatting.`;\r\n\r\n    const timeoutPromise = new Promise((_, reject) => {\r\n      setTimeout(\r\n        () => reject(new Error(\"Feedback generation timeout\")),\r\n        30 * 1000 // 30 seconds\r\n      );\r\n    });\r\n\r\n    const feedbackPromise = retryWithBackoff(async () => {\r\n      const res = await llm.invoke(prompt);\r\n      const text = res.content.trim();\r\n\r\n      let json;\r\n      try {\r\n        const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\r\n        if (jsonMatch) {\r\n          json = JSON.parse(jsonMatch[0]);\r\n        } else {\r\n          throw new Error(\"No JSON found in response\");\r\n        }\r\n      } catch (parseError) {\r\n        log.error({ parseError, text: text.substring(0, 200) }, \"Failed to parse feedback response\");\r\n        throw new Error(\"Invalid JSON response from LLM\");\r\n      }\r\n\r\n      // Validate response\r\n      if (typeof json.overallScore !== \"number\" || json.overallScore < 0 || json.overallScore > 10) {\r\n        throw new Error(\"Invalid overallScore in feedback response\");\r\n      }\r\n\r\n      return {\r\n        overallScore: Math.max(0, Math.min(10, Math.round(json.overallScore))),\r\n        summary: json.summary?.trim() || \"\",\r\n        strengths: Array.isArray(json.strengths) ? json.strengths.map(s => String(s).trim()) : [],\r\n        weaknesses: Array.isArray(json.weaknesses) ? json.weaknesses.map(w => String(w).trim()) : [],\r\n        recommendations: Array.isArray(json.recommendations) ? json.recommendations.map(r => String(r).trim()) : [],\r\n        detailedFeedback: json.detailedFeedback?.trim() || \"\",\r\n      };\r\n    });\r\n\r\n    const result = await Promise.race([feedbackPromise, timeoutPromise]);\r\n    log.debug({ overallScore: result.overallScore }, \"Overall feedback generated\");\r\n    return result;\r\n  } catch (error) {\r\n    log.error({ error }, \"Failed to generate overall feedback\");\r\n    \r\n    // Return fallback feedback\r\n    return {\r\n      overallScore: 5,\r\n      summary: language === \"ar\" \r\n        ? \"ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ù‚Ø§Ø¨Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­.\"\r\n        : \"Interview completed successfully.\",\r\n      strengths: [],\r\n      weaknesses: [],\r\n      recommendations: [],\r\n      detailedFeedback: language === \"ar\"\r\n        ? \"Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ø¹Ù„Ù‰ Ù…Ø´Ø§Ø±ÙƒØªÙƒ ÙÙŠ Ø§Ù„Ù…Ù‚Ø§Ø¨Ù„Ø©.\"\r\n        : \"Thank you for participating in the interview.\",\r\n    };\r\n  }\r\n}\r\n",
      "interview.fsm.js": "export async function transitionSession(session, event, payload = {}) {\r\n  switch (event) {\r\n    case \"START\": {\r\n      if (session.state) return session;\r\n\r\n      session.status = \"started\";\r\n      session.state = \"ASKING_QUESTION\";\r\n      session.startedAt = new Date();\r\n      break;\r\n    }\r\n\r\n    case \"ANSWER\": {\r\n      if (session.state !== \"WAITING_FOR_ANSWER\") {\r\n        throw new Error(\"Invalid state for ANSWER\");\r\n      }\r\n\r\n      session.transcript.push({\r\n        role: \"user\",\r\n        content: payload.answer,\r\n      });\r\n\r\n      session.state = \"PROCESSING_ANSWER\";\r\n      break;\r\n    }\r\n\r\n    case \"NEXT_QUESTION\": {\r\n      session.currentQuestionIndex += 1;\r\n      session.state = \"ASKING_QUESTION\";\r\n      break;\r\n    }\r\n\r\n    case \"END\": {\r\n      session.status = \"completed\";\r\n      session.state = \"COMPLETED\";\r\n      session.endedAt = new Date();\r\n      break;\r\n    }\r\n\r\n    default:\r\n      throw new Error(`Unknown FSM event: ${event}`);\r\n  }\r\n\r\n  await session.save();\r\n  return session;\r\n}\r\n",
      "interview.ratelimit.js": "import Redis from \"ioredis\";\r\nimport { getRedisConnection } from \"../../config/redis.js\";\r\nimport { RATE_LIMITS } from \"./interview.constants.js\";\r\nimport logger from \"../../utils/logger.js\";\r\n\r\n/**\r\n * Redis-based Rate Limiter for Interview Socket\r\n * Uses sliding window algorithm\r\n */\r\n\r\nlet redisClient = null;\r\n\r\n/**\r\n * Initialize Redis client\r\n */\r\nfunction getRedisClient() {\r\n  if (!redisClient) {\r\n    const connection = getRedisConnection();\r\n    redisClient = connection.url\r\n      ? new Redis(connection.url)\r\n      : new Redis(connection);\r\n    \r\n    redisClient.on(\"error\", (err) => {\r\n      logger.error({ err }, \"Redis rate limiter connection error\");\r\n    });\r\n  }\r\n  return redisClient;\r\n}\r\n\r\n/**\r\n * Check if request is within rate limit\r\n * @param {string} key - Rate limit key (e.g., sessionId:answers)\r\n * @param {number} limit - Maximum requests per window\r\n * @param {number} windowSeconds - Time window in seconds\r\n * @returns {Promise<{allowed: boolean, remaining: number, resetAt: number}>}\r\n */\r\nexport async function checkRateLimit(key, limit, windowSeconds = 60) {\r\n  try {\r\n    const client = getRedisClient();\r\n    const now = Date.now();\r\n    const windowMs = windowSeconds * 1000;\r\n    const windowStart = now - windowMs;\r\n\r\n    // Use sorted set to track requests in sliding window\r\n    const redisKey = `ratelimit:${key}`;\r\n    \r\n    // Remove old entries outside the window\r\n    await client.zremrangebyscore(redisKey, 0, windowStart);\r\n    \r\n    // Count current requests in window\r\n    const count = await client.zcard(redisKey);\r\n    \r\n    if (count >= limit) {\r\n      // Get oldest request timestamp to calculate reset time\r\n      const oldest = await client.zrange(redisKey, 0, 0, \"WITHSCORES\");\r\n      const resetAt = oldest.length > 0 \r\n        ? parseInt(oldest[1]) + windowMs \r\n        : now + windowMs;\r\n      \r\n      return {\r\n        allowed: false,\r\n        remaining: 0,\r\n        resetAt,\r\n      };\r\n    }\r\n\r\n    // Add current request\r\n    await client.zadd(redisKey, now, `${now}-${Math.random()}`);\r\n    await client.expire(redisKey, windowSeconds);\r\n\r\n    return {\r\n      allowed: true,\r\n      remaining: limit - count - 1,\r\n      resetAt: now + windowMs,\r\n    };\r\n  } catch (error) {\r\n    logger.error({ error, key }, \"Rate limit check failed\");\r\n    // On error, allow request (fail open)\r\n    return {\r\n      allowed: true,\r\n      remaining: limit,\r\n      resetAt: Date.now() + windowSeconds * 1000,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check rate limit for answer submissions\r\n * @param {string} sessionId - Session ID\r\n * @returns {Promise<{allowed: boolean, remaining: number, resetAt: number}>}\r\n */\r\nexport async function checkAnswerRateLimit(sessionId) {\r\n  return checkRateLimit(\r\n    `session:${sessionId}:answers`,\r\n    RATE_LIMITS.ANSWERS_PER_MINUTE,\r\n    60\r\n  );\r\n}\r\n\r\n/**\r\n * Check rate limit for audio submissions\r\n * @param {string} socketId - Socket ID\r\n * @returns {Promise<{allowed: boolean, remaining: number, resetAt: number}>}\r\n */\r\nexport async function checkAudioRateLimit(socketId) {\r\n  return checkRateLimit(\r\n    `socket:${socketId}:audio`,\r\n    RATE_LIMITS.AUDIO_PER_MINUTE,\r\n    60\r\n  );\r\n}\r\n\r\n/**\r\n * Check rate limit for question generation\r\n * @param {string} sessionId - Session ID\r\n * @returns {Promise<{allowed: boolean, remaining: number, resetAt: number}>}\r\n */\r\nexport async function checkQuestionRateLimit(sessionId) {\r\n  return checkRateLimit(\r\n    `session:${sessionId}:questions`,\r\n    RATE_LIMITS.QUESTIONS_PER_MINUTE,\r\n    60\r\n  );\r\n}\r\n\r\n",
      "interview.routes.js": "import { Router } from \"express\";\r\nimport {\r\n  generateQuestions,\r\n  getUserSessions,\r\n  getSessionById,\r\n  deleteSession,\r\n} from \"./interview.controller.js\";\r\nimport { protect } from \"../../middleware/auth.middleware.js\";\r\nimport { startInterview } from \"./interview.controller.js\";\r\n\r\nconst router = Router();\r\n\r\n// Question generation route\r\nrouter.post(\"/\", protect, generateQuestions);\r\n\r\n// Session management routes\r\nrouter.get(\"/sessions\", protect, getUserSessions);\r\nrouter.get(\"/sessions/:sessionId\", protect, getSessionById);\r\nrouter.delete(\"/sessions/:sessionId\", protect, deleteSession);\r\n\r\nrouter.post(\"/start\", protect, startInterview);\r\n\r\nexport default router;\r\n",
      "interview.service.js": "import { ChatOpenAI } from \"@langchain/openai\";\nimport { AppError } from \"../../utils/AppError.js\";\nimport User from \"../auth/user.model.js\";\nimport InterviewSession from \"./interview-session.model.js\";\n\nconst openai = new ChatOpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n  model: \"gpt-4o\",\n  temperature: 0.7,\n});\n\n/**\n * Generate interview questions based on user's technical skills\n */\nexport async function generateInterviewQuestions(userId) {\n  try {\n    // Fetch user with technical skills\n    const user = await User.findById(userId);\n    if (!user) {\n      throw new AppError(\"User not found\", 404);\n    }\n\n    // Check if user has technical skills\n    const technicalSkills = user.document?.technicalSkills || [];\n    if (!technicalSkills || technicalSkills.length === 0) {\n      throw new AppError(\n        \"No technical skills found. Please upload your CV first.\",\n        400\n      );\n    }\n\n    const yearsOfExperience = user.document?.yearsOfExperience || null;\n\n    // Construct prompt for OpenAI\n    const skillsList = technicalSkills.join(\", \");\n    const experienceContext = yearsOfExperience\n      ? `The candidate has ${yearsOfExperience} years of professional experience.`\n      : \"\";\n\n    const prompt = `You are an expert interview question generator. Generate personalized interview questions based on the following candidate profile:\n\nTechnical Skills: ${skillsList}\n${experienceContext}\n\nGenerate a balanced mix of interview questions (equal distribution across all three types). Return exactly 15 questions total: 5 technical, 5 behavioral, and 5 situational questions.\n\nFor each question, provide:\n- A clear, specific question\n- Category (technical, behavioral, or situational)\n- Difficulty level (beginner, intermediate, or advanced)\n- 3-5 helpful tips for answering the question\n\nReturn your response as a valid JSON array in this exact format:\n[\n  {\n    \"question\": \"string\",\n    \"category\": \"technical\" | \"behavioral\" | \"situational\",\n    \"difficulty\": \"beginner\" | \"intermediate\" | \"advanced\",\n    \"tips\": [\"tip1\", \"tip2\", \"tip3\"]\n  }\n]\n\nGuidelines:\n- Technical questions should be specific to the candidate's skills (${skillsList})\n- Behavioral questions should assess soft skills and work experience\n- Situational questions should present realistic work scenarios\n- Difficulty should match the candidate's experience level\n- Tips should be actionable and specific\n- Ensure questions are relevant to the candidate's technical background\n\nReturn ONLY valid JSON, no additional text or markdown formatting.`;\n\n    // Get response from OpenAI\n    const response = await openai.invoke(prompt);\n    const responseText = response.content.trim();\n\n    // Parse JSON response\n    let questions;\n    try {\n      // Remove markdown code blocks if present\n      const jsonMatch = responseText.match(/\\[[\\s\\S]*\\]/);\n      if (jsonMatch) {\n        questions = JSON.parse(jsonMatch[0]);\n      } else {\n        questions = JSON.parse(responseText);\n      }\n    } catch (parseError) {\n      throw new AppError(\"Failed to parse interview questions response\", 500);\n    }\n\n    // Validate questions structure\n    if (!Array.isArray(questions)) {\n      throw new AppError(\"Invalid response format: expected array\", 500);\n    }\n\n    // Validate each question has required fields\n    const validatedQuestions = questions\n      .filter((q) => {\n        return (\n          q.question &&\n          q.category &&\n          q.difficulty &&\n          Array.isArray(q.tips) &&\n          [\"technical\", \"behavioral\", \"situational\"].includes(q.category) &&\n          [\"beginner\", \"intermediate\", \"advanced\"].includes(q.difficulty)\n        );\n      })\n      .map((q) => ({\n        question: String(q.question).trim(),\n        category: q.category,\n        difficulty: q.difficulty,\n        tips: q.tips\n          .map((tip) => String(tip).trim())\n          .filter((tip) => tip.length > 0),\n      }));\n\n    if (validatedQuestions.length === 0) {\n      throw new AppError(\"No valid questions generated\", 500);\n    }\n\n    return validatedQuestions;\n  } catch (error) {\n    if (error instanceof AppError) {\n      throw error;\n    }\n    throw new AppError(\"Failed to generate interview questions\", 500);\n  }\n}\n\n/**\n * Generate next interview question based on conversation context\n */\nexport async function generateNextQuestion(session, userId) {\n  try {\n    // Fetch user with technical skills\n    const user = await User.findById(userId);\n    if (!user) {\n      throw new AppError(\"User not found\", 404);\n    }\n\n    const technicalSkills = user.document?.technicalSkills || [];\n    const yearsOfExperience = user.document?.yearsOfExperience || null;\n\n    // Build conversation context from transcript (only recent messages)\n    const conversationHistory = session.transcript\n      .slice(-6) // Only last 3 Q&A pairs for context\n      .map((msg) => `${msg.role}: ${msg.content}`)\n      .join(\"\\n\");\n\n    // Get previously asked questions\n    const previousQuestions = session.questions\n      .map((q) => q.text)\n      .join(\"\\n\");\n\n    // Build context summary\n    const skillsList = technicalSkills.join(\", \");\n    const experienceContext = yearsOfExperience\n      ? `${yearsOfExperience} years of experience`\n      : \"entry level\";\n\n    const currentQuestionIndex = session.currentQuestionIndex || 0;\n    const totalQuestionsAsked = session.questions.length;\n\n    // Determine question type - ensure variety\n    let questionType;\n    const questionTypes = [\"technical\", \"behavioral\", \"situational\"];\n    const lastTypes = session.questions.slice(-3).map(q => q.category);\n    \n    // Avoid repeating same type 3 times in a row\n    const availableTypes = questionTypes.filter(type => \n      lastTypes.filter(t => t === type).length < 2\n    );\n    questionType = availableTypes.length > 0 \n      ? availableTypes[Math.floor(Math.random() * availableTypes.length)]\n      : questionTypes[totalQuestionsAsked % 3];\n\n    const prompt = `You are a professional interviewer having a natural, engaging conversation with a candidate.\n\nCANDIDATE PROFILE:\n- Technical Skills: ${skillsList}\n- Experience Level: ${experienceContext}\n\nRECENT CONVERSATION:\n${conversationHistory || \"Just started - this is after the introduction.\"}\n\nPREVIOUSLY ASKED QUESTIONS (DO NOT REPEAT ANY OF THESE):\n${previousQuestions}\n\nINTERVIEW PROGRESS:\n- Question #${totalQuestionsAsked + 1} (out of 8 total)\n- Next question type: ${questionType}\n\nCRITICAL INSTRUCTIONS:\n1. Generate ONE NEW question that:\n   - Is COMPLETELY DIFFERENT from all previous questions\n   - Builds naturally on the recent conversation\n   - Type: ${questionType}\n   - Difficulty: ${experienceContext}\n\n2. Make it feel like a HUMAN conversation:\n   - Reference their previous answers naturally if relevant\n   - Show genuine interest in their responses\n   - Use conversational language, not robotic or formal\n   - Ask follow-ups that make sense contextually\n   - Be warm and engaging\n\n3. For question types:\n   - Technical: Ask about specific skills or technologies (${skillsList})\n   - Behavioral: Ask about past experiences, challenges, or accomplishments\n   - Situational: Present realistic work scenarios or problem-solving situations\n\n4. Keep it concise and natural (1-2 sentences max)\n5. Avoid generic questions - make it personal and relevant\n\nReturn ONLY valid JSON in this exact format:\n{\n  \"question\": \"the question text\",\n  \"category\": \"${questionType}\",\n  \"difficulty\": \"beginner\" | \"intermediate\" | \"advanced\",\n  \"tips\": [\"tip1\", \"tip2\", \"tip3\"]\n}\n\nReturn ONLY valid JSON, no additional text or markdown formatting.`;\n\n    // Get response from OpenAI\n    const response = await openai.invoke(prompt);\n    const responseText = response.content.trim();\n\n    // Parse JSON response\n    let question;\n    try {\n      // Remove markdown code blocks if present\n      const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        question = JSON.parse(jsonMatch[0]);\n      } else {\n        question = JSON.parse(responseText);\n      }\n    } catch (parseError) {\n      throw new AppError(\"Failed to parse question response\", 500);\n    }\n\n    // Validate question structure\n    if (\n      !question.question ||\n      !question.category ||\n      !question.difficulty ||\n      !Array.isArray(question.tips)\n    ) {\n      throw new AppError(\"Invalid question format\", 500);\n    }\n\n    if (\n      ![\"technical\", \"behavioral\", \"situational\"].includes(question.category)\n    ) {\n      throw new AppError(\"Invalid question category\", 500);\n    }\n\n    if (\n      ![\"beginner\", \"intermediate\", \"advanced\"].includes(question.difficulty)\n    ) {\n      throw new AppError(\"Invalid question difficulty\", 500);\n    }\n\n    return {\n      question: String(question.question).trim(),\n      category: question.category,\n      difficulty: question.difficulty,\n      tips: question.tips\n        .map((tip) => String(tip).trim())\n        .filter((tip) => tip.length > 0),\n    };\n  } catch (error) {\n    if (error instanceof AppError) {\n      throw error;\n    }\n    throw new AppError(\"Failed to generate next question\", 500);\n  }\n}\n\nexport async function startInterviewSession({\n  userId,\n  language,\n  interviewerStyle,\n  voice,\n}) {\n  // 1. Validate user & CV\n  const user = await User.findById(userId);\n  if (!user) {\n    throw new AppError(\"User not found\", 404);\n  }\n\n  if (!user.document || !user.document.fileName) {\n    throw new AppError(\n      \"You must upload your CV before starting an interview\",\n      400\n    );\n  }\n\n  // 2. Check active interview\n  const activeSession = await InterviewSession.findOne({\n    userId,\n    status: \"active\",\n  });\n\n  if (activeSession) {\n    throw new AppError(\"You already have an active interview\", 409);\n  }\n\n  // 3. Create session\n  const session = await InterviewSession.create({\n    userId,\n    interviewType: \"voice\",\n    language: language || \"en\",\n    interviewerStyle: interviewerStyle || \"technical\",\n    voice: voice || \"neutral\",\n\n    metadata: {\n      technicalSkills: user.document.technicalSkills || [],\n      yearsOfExperience: user.document.yearsOfExperience || null,\n      personalInformation: {\n        fullName: user.document.personalInformation?.fullName,\n        email: user.document.personalInformation?.email,\n      },\n    },\n\n    status: \"active\",\n    startedAt: new Date(),\n  });\n\n  return session;\n}\n\n/**\n * Generate personalized welcome message using LLM\n */\nexport async function generateWelcomeMessage(userId, language = \"en\", interviewerStyle = \"technical\") {\n  try {\n    const user = await User.findById(userId);\n    if (!user) {\n      throw new AppError(\"User not found\", 404);\n    }\n\n    const userName = user.document?.personalInformation?.fullName || \"there\";\n    const technicalSkills = user.document?.technicalSkills || [];\n    const yearsOfExperience = user.document?.yearsOfExperience || null;\n\n    const skillsList = technicalSkills.length > 0 \n      ? technicalSkills.slice(0, 5).join(\", \")\n      : \"your background\";\n    \n    const experienceContext = yearsOfExperience\n      ? `The candidate has ${yearsOfExperience} years of professional experience.`\n      : \"\";\n\n    const styleContext = {\n      technical: language === \"ar\" \n        ? \"ÙƒÙ† Ù…Ø­ØªØ±ÙØ§Ù‹ ÙˆØªÙ‚Ù†ÙŠØ§Ù‹ ÙÙŠ Ø£Ø³Ù„ÙˆØ¨Ùƒ\"\n        : \"Be professional and technical in your approach\",\n      friendly: language === \"ar\"\n        ? \"ÙƒÙ† ÙˆØ¯ÙˆØ¯Ø§Ù‹ ÙˆÙ…Ø±Ø­Ø¨Ø§Ù‹ ÙÙŠ Ø£Ø³Ù„ÙˆØ¨Ùƒ\"\n        : \"Be friendly and welcoming in your approach\",\n      formal: language === \"ar\"\n        ? \"ÙƒÙ† Ø±Ø³Ù…ÙŠØ§Ù‹ ÙˆÙ…Ù‡Ø°Ø¨Ø§Ù‹ ÙÙŠ Ø£Ø³Ù„ÙˆØ¨Ùƒ\"\n        : \"Be formal and polite in your approach\",\n    };\n\n    const prompt = `You are a friendly professional interviewer starting a natural conversation with a real person.\n\nCandidate: ${userName}\nSkills: ${skillsList}\n${experienceContext}\n\nYour task:\n1. Greet them warmly like a real human interviewer would (use a real name, not placeholders)\n2. Introduce yourself naturally and genuinely\n3. Make them feel comfortable and excited\n4. Let them know you're looking forward to talking with them\n5. Keep it natural, warm, and conversational (2 sentences)\n\nLanguage: ${language}\nStyle: ${interviewerStyle}\n\nIMPORTANT: Sound like a real person having a genuine conversation, not an AI or robot. Be warm, authentic, and human.\n\nReturn ONLY the welcome message text, no additional formatting or explanations.`;\n\n    const response = await openai.invoke(prompt);\n    return response.content.trim();\n  } catch (error) {\n    // Fallback to default message\n    if (error instanceof AppError) {\n      throw error;\n    }\n    return language === \"ar\"\n      ? \"Ø£Ù‡Ù„Ø§Ù‹ØŒ Ø®Ù„Ù‘ÙŠÙ†Ø§ Ù†Ø¨Ø¯Ø£ Ø§Ù„Ø§Ù†ØªØ±ÙÙŠÙˆ. Ù…Ù…ÙƒÙ† ØªØ¹Ø±ÙÙ†Ø§ Ø¨Ù†ÙØ³Ùƒ Ø´ÙˆÙŠØ©ØŸ\"\n      : \"Welcome. Let's start the interview. Could you please introduce yourself?\";\n  }\n}\n\n/**\n * Generate opening/introduction question\n */\nexport async function generateOpeningQuestion(userId, language = \"en\", interviewerStyle = \"technical\") {\n  try {\n    const user = await User.findById(userId);\n    if (!user) {\n      throw new AppError(\"User not found\", 404);\n    }\n\n    const userName = user.document?.personalInformation?.fullName || \"there\";\n\n    const prompt = `You are a professional interviewer starting a job interview conversation.\n\nCandidate: ${userName}\nLanguage: ${language}\nStyle: ${interviewerStyle}\n\nYour task: Create a warm, natural opening question that asks the candidate to introduce themselves.\n\nRequirements:\n1. Be conversational and human-like\n2. Ask them to tell you about themselves and their background\n3. Make it feel like a real human conversation, not an AI\n4. Keep it brief (one clear sentence)\n5. Be warm and encouraging\n\nReturn ONLY valid JSON:\n{\n  \"question\": \"the opening question\",\n  \"category\": \"behavioral\",\n  \"difficulty\": \"beginner\"\n}\n\nReturn ONLY valid JSON, no additional text or markdown formatting.`;\n\n    const response = await openai.invoke(prompt);\n    const text = response.content.trim();\n\n    let question;\n    try {\n      const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        question = JSON.parse(jsonMatch[0]);\n      } else {\n        question = JSON.parse(text);\n      }\n    } catch (parseError) {\n      throw new Error(\"Failed to parse opening question\");\n    }\n\n    return {\n      question: question.question?.trim() || (language === \"ar\" \n        ? \"Ù…Ù…ÙƒÙ† ØªØ­ÙƒÙŠÙ„ÙŠ Ø´ÙˆÙŠØ© Ø¹Ù† Ù†ÙØ³Ùƒ ÙˆØ®Ø¨Ø±Ø§ØªÙƒØŸ\" \n        : \"Could you tell me a bit about yourself and your experience?\"),\n      category: \"behavioral\",\n      difficulty: \"beginner\",\n    };\n  } catch (error) {\n    // Fallback\n    return {\n      question: language === \"ar\"\n        ? \"Ù…Ù…ÙƒÙ† ØªØ­ÙƒÙŠÙ„ÙŠ Ø´ÙˆÙŠØ© Ø¹Ù† Ù†ÙØ³Ùƒ ÙˆØ®Ø¨Ø±Ø§ØªÙƒØŸ\"\n        : \"Could you tell me a bit about yourself and your experience?\",\n      category: \"behavioral\",\n      difficulty: \"beginner\",\n    };\n  }\n}\n\n/**\n * Generate personalized farewell message using LLM\n */\nexport async function generateFarewellMessage(\n  userId,\n  session,\n  language = \"en\",\n  interviewerStyle = \"technical\"\n) {\n  try {\n    const user = await User.findById(userId);\n    if (!user) {\n      throw new AppError(\"User not found\", 404);\n    }\n\n    const userName = user.document?.personalInformation?.fullName || \"there\";\n    const questionsAnswered = session.questions?.length || 0;\n\n    const styleContext = {\n      technical: language === \"ar\"\n        ? \"ÙƒÙ† Ù…Ø­ØªØ±ÙØ§Ù‹ ÙˆØªÙ‚Ù†ÙŠØ§Ù‹\"\n        : \"Be professional and technical\",\n      friendly: language === \"ar\"\n        ? \"ÙƒÙ† ÙˆØ¯ÙˆØ¯Ø§Ù‹ ÙˆØ¯Ø§ÙØ¦Ø§Ù‹\"\n        : \"Be friendly and warm\",\n      formal: language === \"ar\"\n        ? \"ÙƒÙ† Ø±Ø³Ù…ÙŠØ§Ù‹ ÙˆÙ…Ù‡Ø°Ø¨Ø§Ù‹\"\n        : \"Be formal and polite\",\n    };\n\n    const prompt = `You are a professional interviewer concluding a ${language === \"ar\" ? \"Ù…Ù‚Ø§Ø¨Ù„Ø©\" : \"job interview\"}.\n\nCandidate Information:\n- Name: ${userName}\n- Questions answered: ${questionsAnswered}\n\nYour task:\n1. Thank the candidate for their time and participation\n2. Express appreciation for their answers\n3. Wish them well\n4. Keep it natural, warm, and ${styleContext[interviewerStyle] || styleContext.technical}\n5. Keep it brief (2-3 sentences maximum)\n\nLanguage: ${language}\nStyle: ${interviewerStyle}\n\nReturn ONLY the farewell message text, no additional formatting or explanations.`;\n\n    const response = await openai.invoke(prompt);\n    return response.content.trim();\n  } catch (error) {\n    // Fallback to default message\n    if (error instanceof AppError) {\n      throw error;\n    }\n    return language === \"ar\"\n      ? \"Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ø¹Ù„Ù‰ ÙˆÙ‚ØªÙƒ ÙˆÙ…Ø´Ø§Ø±ÙƒØªÙƒ ÙÙŠ Ø§Ù„Ù…Ù‚Ø§Ø¨Ù„Ø©. Ù†ØªÙ…Ù†Ù‰ Ù„Ùƒ Ø§Ù„ØªÙˆÙÙŠÙ‚!\"\n      : \"Thank you for your time and participation in the interview. We wish you the best!\";\n  }\n}\n",
      "interview.socket.js": "import mongoose from \"mongoose\";\nimport { Mutex } from \"async-mutex\";\nimport InterviewSession from \"./interview-session.model.js\";\nimport { transitionSession } from \"./interview.fsm.js\";\nimport {\n  generateNextQuestion,\n  generateWelcomeMessage,\n  generateFarewellMessage,\n  generateOpeningQuestion,\n} from \"./interview.service.js\";\nimport {\n  evaluateAnswer,\n  checkTerminationIntent,\n  generateOverallFeedback,\n} from \"./interview.evaluation.js\";\nimport { speechToText } from \"./interview.stt.js\";\nimport { queueTTS } from \"./interview.tts.queue.js\";\nimport {\n  SOCKET_EVENTS,\n  SESSION_STATES,\n  VALIDATION_LIMITS,\n  VALID_AUDIO_TYPES,\n  TIMEOUTS,\n  WELCOME_MESSAGES,\n  INTERVIEW_LIMITS,\n} from \"./interview.constants.js\";\nimport {\n  checkAnswerRateLimit,\n  checkAudioRateLimit,\n} from \"./interview.ratelimit.js\";\nimport {\n  cacheSession,\n  getCachedSession,\n  invalidateSessionCache,\n  updateCachedSession,\n} from \"./interview.cache.js\";\nimport { createLogger } from \"../../utils/logger.js\";\n\n/**\n * Register Interview Socket Namespace\n * Namespace: /interview\n */\nexport function registerInterviewSocket(io) {\n  const interviewNamespace = io.of(\"/interview\");\n  const logger = createLogger({ module: \"interview-socket\" });\n\n  // Mutex map for session-level locking\n  const sessionMutexes = new Map();\n\n  // Timeout map for answer timeouts\n  const answerTimeouts = new Map();\n\n  // Get or create mutex for a session\n  function getSessionMutex(sessionId) {\n    const sessionIdStr = sessionId.toString();\n    if (!sessionMutexes.has(sessionIdStr)) {\n      sessionMutexes.set(sessionIdStr, new Mutex());\n    }\n    return sessionMutexes.get(sessionIdStr);\n  }\n\n  // Cleanup session resources\n  function cleanupSessionResources(sessionId, socketId) {\n    const sessionIdStr = sessionId.toString();\n\n    // Clear timeout\n    if (answerTimeouts.has(sessionIdStr)) {\n      clearTimeout(answerTimeouts.get(sessionIdStr));\n      answerTimeouts.delete(sessionIdStr);\n    }\n\n    // Note: Don't delete mutex - it might be needed for cleanup operations\n  }\n\n  // Middleware to validate auth before connection\n  interviewNamespace.use(async (socket, next) => {\n    const { sessionId, userId } = socket.handshake.auth || {};\n\n    if (!sessionId || !userId) {\n      logger.error({ sessionId, userId }, \"Connection rejected - missing auth\");\n      return next(new Error(\"Missing sessionId or userId in handshake.auth\"));\n    }\n\n    // Validate session exists\n    try {\n      const session = await InterviewSession.findOne({\n        _id: sessionId,\n        userId,\n        status: { $in: [\"active\", \"started\"] }, // Accept both active and started\n      });\n\n      if (!session) {\n        logger.error(\n          { sessionId, userId },\n          \"Connection rejected - invalid session\"\n        );\n        return next(new Error(\"Invalid or inactive interview session\"));\n      }\n\n      next();\n    } catch (error) {\n      logger.error({ error, sessionId, userId }, \"Connection error\");\n      next(new Error(\"Failed to validate session\"));\n    }\n  });\n\n  // Handle connection errors\n  interviewNamespace.on(\"connection_error\", (err) => {\n    logger.error({ err }, \"Interview namespace connection error\");\n  });\n\n  interviewNamespace.on(\"connection\", async (socket) => {\n    const { sessionId, userId } = socket.handshake.auth || {};\n    const socketLogger = createLogger({\n      module: \"interview-socket\",\n      socketId: socket.id,\n      sessionId,\n      userId,\n    });\n\n    socketLogger.info(\"Interview socket connected\");\n\n    let workingSession = null;\n    let sessionMutex = null;\n\n    try {\n      // Load session (check cache first)\n      let session = await getCachedSession(sessionId);\n\n      if (!session) {\n        session = await InterviewSession.findOne({\n          _id: sessionId,\n          userId,\n          status: { $in: [\"active\", \"started\"] }, // Accept both active and started\n        }).lean();\n\n        if (session) {\n          await cacheSession(sessionId, session);\n        }\n      }\n\n      if (!session) {\n        socket.emit(SOCKET_EVENTS.ERROR, {\n          message: \"Invalid or inactive interview session\",\n        });\n        socket.disconnect();\n        return;\n      }\n\n      workingSession = session;\n      sessionMutex = getSessionMutex(sessionId);\n\n      // Join room\n      socket.join(sessionId);\n\n      // Generate opening question if needed\n      if (!session.questions || session.questions.length === 0) {\n        socketLogger.debug(\"Generating opening question\");\n\n        try {\n          const openingQuestion = await generateOpeningQuestion(\n            userId,\n            session.language || \"en\",\n            session.interviewerStyle || \"technical\"\n          );\n\n          // Update session with opening question\n          const updatedSession = await InterviewSession.findByIdAndUpdate(\n            sessionId,\n            {\n              $push: {\n                questions: {\n                  text: openingQuestion.question,\n                  category: openingQuestion.category,\n                  difficulty: openingQuestion.difficulty,\n                  askedAt: new Date(),\n                },\n              },\n            },\n            { new: true }\n          ).lean();\n\n          workingSession = updatedSession;\n          await cacheSession(sessionId, updatedSession);\n          socketLogger.debug(\"Opening question generated\");\n        } catch (error) {\n          socketLogger.error({ error }, \"Error generating opening question\");\n          socket.emit(SOCKET_EVENTS.ERROR, {\n            message:\n              \"Failed to generate interview question. Please upload your CV first.\",\n          });\n          socket.disconnect();\n          return;\n        }\n      }\n\n      // Convert to Mongoose document for FSM\n      const sessionDoc = await InterviewSession.findById(sessionId);\n      await transitionSession(sessionDoc, \"START\");\n      workingSession = sessionDoc.toObject();\n      await cacheSession(sessionId, workingSession);\n\n      // Send personalized welcome message from LLM\n      try {\n        const welcomeText = await generateWelcomeMessage(\n          userId,\n          workingSession.language || \"en\",\n          workingSession.interviewerStyle || \"technical\"\n        );\n\n        socket.emit(SOCKET_EVENTS.MESSAGE, {\n          type: \"system\",\n          text: welcomeText,\n        });\n\n        // Queue TTS for welcome message\n        queueTTS(\n          socket,\n          welcomeText,\n          workingSession.voice || \"alloy\",\n          workingSession.language || \"en\",\n          { sessionId, type: \"welcome\" }\n        );\n      } catch (error) {\n        socketLogger.error({ error }, \"Error generating welcome message\");\n        // Fallback to default message\n        const welcomeText =\n          WELCOME_MESSAGES[workingSession.language] || WELCOME_MESSAGES.en;\n        socket.emit(SOCKET_EVENTS.MESSAGE, {\n          type: \"system\",\n          text: welcomeText,\n        });\n        queueTTS(\n          socket,\n          welcomeText,\n          workingSession.voice || \"alloy\",\n          workingSession.language || \"en\",\n          { sessionId, type: \"welcome\" }\n        );\n      }\n\n      // Send first question\n      const question =\n        workingSession.questions[workingSession.currentQuestionIndex];\n\n      if (!question) {\n        socket.emit(SOCKET_EVENTS.ERROR, {\n          message: \"No questions available for this interview\",\n        });\n        socket.disconnect();\n        return;\n      }\n\n      await sendQuestionWithTTS(socket, question, workingSession, sessionId);\n\n      // Set state to waiting for answer\n      await InterviewSession.findByIdAndUpdate(sessionId, {\n        state: SESSION_STATES.WAITING_FOR_ANSWER,\n      });\n      await updateCachedSession(sessionId, {\n        state: SESSION_STATES.WAITING_FOR_ANSWER,\n      });\n\n      // Set answer timeout\n      setAnswerTimeout(\n        socket,\n        sessionId,\n        workingSession.language,\n        socketLogger\n      );\n\n      // Register event handlers\n      registerEventHandlers(\n        socket,\n        sessionId,\n        userId,\n        workingSession,\n        sessionMutex,\n        socketLogger\n      );\n    } catch (error) {\n      socketLogger.error({ error }, \"Interview socket initialization failed\");\n      socket.emit(SOCKET_EVENTS.ERROR, {\n        message: \"Interview socket initialization failed\",\n      });\n      socket.disconnect();\n    }\n  });\n\n  /**\n   * Send question with TTS\n   */\n  async function sendQuestionWithTTS(socket, question, session, sessionId) {\n    socket.emit(SOCKET_EVENTS.QUESTION, {\n      text: question.text,\n      category: question.category,\n    });\n\n    queueTTS(\n      socket,\n      question.text,\n      session.voice || \"alloy\",\n      session.language || \"en\",\n      { sessionId, type: \"question\", questionId: question._id }\n    );\n  }\n\n  /**\n   * Set answer timeout\n   */\n  function setAnswerTimeout(socket, sessionId, language, socketLogger) {\n    const sessionIdStr = sessionId.toString();\n\n    // Clear existing timeout\n    if (answerTimeouts.has(sessionIdStr)) {\n      clearTimeout(answerTimeouts.get(sessionIdStr));\n    }\n\n    // Set new timeout\n    const timeout = setTimeout(() => {\n      socketLogger.warn(\"Answer timeout reached\");\n      socket.emit(SOCKET_EVENTS.MESSAGE, {\n        type: \"system\",\n        text:\n          language === \"ar\"\n            ? \"Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù„Ù„Ø¥Ø¬Ø§Ø¨Ø©. Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ\"\n            : \"Time limit reached. Would you like to continue?\",\n      });\n      answerTimeouts.delete(sessionIdStr);\n    }, TIMEOUTS.ANSWER_TIMEOUT);\n\n    answerTimeouts.set(sessionIdStr, timeout);\n  }\n\n  /**\n   * Register all event handlers\n   */\n  function registerEventHandlers(\n    socket,\n    sessionId,\n    userId,\n    initialSession,\n    sessionMutex,\n    socketLogger\n  ) {\n    // Health check\n    socket.on(SOCKET_EVENTS.PING, (callback) => {\n      if (typeof callback === \"function\") {\n        callback({\n          status: \"ok\",\n          timestamp: Date.now(),\n          sessionId: sessionId.toString(),\n        });\n      }\n    });\n\n    // Handle text answer\n    socket.on(SOCKET_EVENTS.ANSWER, async ({ text }) => {\n      await handleAnswer(\n        socket,\n        sessionId,\n        userId,\n        text,\n        sessionMutex,\n        socketLogger\n      );\n    });\n\n    // Handle audio answer\n    socket.on(SOCKET_EVENTS.AUDIO_ANSWER, async ({ audio, mimeType }) => {\n      await handleAudioAnswer(\n        socket,\n        sessionId,\n        userId,\n        audio,\n        mimeType,\n        sessionMutex,\n        socketLogger\n      );\n    });\n\n    // Handle disconnect\n    socket.on(\"disconnect\", async () => {\n      await handleDisconnect(\n        socket,\n        sessionId,\n        userId,\n        sessionMutex,\n        socketLogger\n      );\n    });\n  }\n\n  /**\n   * Handle text answer\n   */\n  async function handleAnswer(\n    socket,\n    sessionId,\n    userId,\n    text,\n    sessionMutex,\n    socketLogger\n  ) {\n    // Input validation\n    if (!text || typeof text !== \"string\") {\n      socket.emit(SOCKET_EVENTS.ERROR, {\n        message: \"Invalid answer format\",\n      });\n      return;\n    }\n\n    const trimmedText = text.trim();\n\n    // Check if user wants to end the interview using LLM\n    const session = await InterviewSession.findById(sessionId).lean();\n    const language = session?.language || \"en\";\n\n    const intentResult = await checkTerminationIntent(trimmedText, language);\n\n    if (intentResult.shouldTerminate && intentResult.confidence > 0.7) {\n      socketLogger.info(\n        {\n          confidence: intentResult.confidence,\n          reason: intentResult.reason,\n        },\n        \"Termination intent detected in text answer\"\n      );\n\n      await endInterviewSession(\n        socket,\n        sessionId,\n        userId,\n        sessionMutex,\n        socketLogger\n      );\n      return; // Don't process as regular answer\n    }\n\n    if (\n      trimmedText.length < VALIDATION_LIMITS.MIN_TEXT_LENGTH ||\n      trimmedText.length > VALIDATION_LIMITS.MAX_TEXT_LENGTH\n    ) {\n      socket.emit(SOCKET_EVENTS.ERROR, {\n        message: `Answer must be between ${VALIDATION_LIMITS.MIN_TEXT_LENGTH} and ${VALIDATION_LIMITS.MAX_TEXT_LENGTH} characters`,\n      });\n      return;\n    }\n\n    // Rate limiting\n    const rateLimit = await checkAnswerRateLimit(sessionId);\n    if (!rateLimit.allowed) {\n      socket.emit(SOCKET_EVENTS.ERROR, {\n        message: \"Too many answers. Please wait before submitting again.\",\n        resetAt: rateLimit.resetAt,\n      });\n      return;\n    }\n\n    // Use mutex to prevent race conditions\n    await sessionMutex.runExclusive(async () => {\n      try {\n        await processAnswer(\n          socket,\n          sessionId,\n          userId,\n          trimmedText,\n          socketLogger\n        );\n      } catch (error) {\n        socketLogger.error({ error }, \"Error processing answer\");\n        socket.emit(SOCKET_EVENTS.ERROR, {\n          message: \"Failed to process answer. Please try again.\",\n        });\n      }\n    });\n  }\n\n  /**\n   * Handle audio answer\n   */\n  async function handleAudioAnswer(\n    socket,\n    sessionId,\n    userId,\n    audio,\n    mimeType,\n    sessionMutex,\n    socketLogger\n  ) {\n    // Input validation\n    if (!audio) {\n      socket.emit(SOCKET_EVENTS.ERROR, {\n        message: \"No audio data provided\",\n      });\n      return;\n    }\n\n    // Validate audio format\n    if (mimeType && !VALID_AUDIO_TYPES.includes(mimeType)) {\n      socket.emit(SOCKET_EVENTS.ERROR, {\n        message: `Invalid audio format. Supported formats: ${VALID_AUDIO_TYPES.join(\n          \", \"\n        )}`,\n      });\n      return;\n    }\n\n    // Validate audio size\n    const audioBuffer = Buffer.from(audio);\n    if (audioBuffer.length > VALIDATION_LIMITS.MAX_AUDIO_SIZE) {\n      socket.emit(SOCKET_EVENTS.ERROR, {\n        message: `Audio size exceeds limit of ${\n          VALIDATION_LIMITS.MAX_AUDIO_SIZE / 1024 / 1024\n        }MB`,\n      });\n      return;\n    }\n\n    // Rate limiting\n    const rateLimit = await checkAudioRateLimit(socket.id);\n    if (!rateLimit.allowed) {\n      socket.emit(SOCKET_EVENTS.ERROR, {\n        message:\n          \"Too many audio submissions. Please wait before submitting again.\",\n        resetAt: rateLimit.resetAt,\n      });\n      return;\n    }\n\n    try {\n      // Convert audio to text\n      const textAnswer = await speechToText(audioBuffer, mimeType);\n\n      // Send transcription to frontend\n      socket.emit(SOCKET_EVENTS.TRANSCRIPTION, {\n        text: textAnswer,\n      });\n\n      // Check if user wants to end the interview using LLM\n      const session = await InterviewSession.findById(sessionId).lean();\n      const language = session?.language || \"en\";\n\n      const intentResult = await checkTerminationIntent(textAnswer, language);\n\n      if (intentResult.shouldTerminate && intentResult.confidence > 0.7) {\n        socketLogger.info(\n          {\n            confidence: intentResult.confidence,\n            reason: intentResult.reason,\n          },\n          \"Termination intent detected in audio answer\"\n        );\n\n        await endInterviewSession(\n          socket,\n          sessionId,\n          userId,\n          sessionMutex,\n          socketLogger\n        );\n        return; // Don't process as regular answer\n      }\n\n      // Process as text answer\n      await handleAnswer(\n        socket,\n        sessionId,\n        userId,\n        textAnswer,\n        sessionMutex,\n        socketLogger\n      );\n    } catch (error) {\n      socketLogger.error({ error }, \"STT error\");\n      socket.emit(SOCKET_EVENTS.ERROR, {\n        message: \"Failed to transcribe audio. Please try again.\",\n      });\n    }\n  }\n\n  /**\n   * Process answer with transaction\n   */\n  async function processAnswer(socket, sessionId, userId, text, socketLogger) {\n    const session = await mongoose.startSession();\n    session.startTransaction();\n\n    try {\n      // Load session within transaction\n      const activeSession = await InterviewSession.findById(sessionId).session(\n        session\n      );\n\n      if (!activeSession) {\n        await session.abortTransaction();\n        socket.emit(SOCKET_EVENTS.ERROR, {\n          message: \"Session not found\",\n        });\n        return;\n      }\n\n      if (activeSession.state !== SESSION_STATES.WAITING_FOR_ANSWER) {\n        await session.abortTransaction();\n        socketLogger.warn(\n          \"Answer received but not in WAITING_FOR_ANSWER state\"\n        );\n        return;\n      }\n\n      // Get current question\n      const questionIndex = activeSession.currentQuestionIndex;\n      const answeredQuestion = activeSession.questions[questionIndex];\n\n      if (!answeredQuestion) {\n        await session.abortTransaction();\n        socket.emit(SOCKET_EVENTS.ERROR, {\n          message: \"No current question found\",\n        });\n        return;\n      }\n\n      // Save answer to transcript\n      await transitionSession(activeSession, \"ANSWER\", {\n        answer: text,\n      });\n\n      // Reload session after transition\n      await activeSession.save({ session });\n\n      // Evaluate answer (but don't send it yet - save it for later)\n      socketLogger.debug(\"Evaluating answer\");\n\n      let evaluation;\n      try {\n        evaluation = await evaluateAnswer({\n          question: answeredQuestion.text,\n          answer: text,\n          difficulty: answeredQuestion.difficulty,\n          language: activeSession.language || \"en\",\n        });\n\n        // Save evaluation to question (don't send to client)\n        // Use set to mark as modified in Mongoose\n        activeSession.questions[questionIndex].answer = text;\n        activeSession.questions[questionIndex].evaluation = {\n          score: evaluation.score,\n          feedback: evaluation.feedback,\n          evaluatedAt: new Date(),\n        };\n\n        // Mark questions array as modified\n        activeSession.markModified(\"questions\");\n        await activeSession.save({ session });\n\n        socketLogger.debug(\n          {\n            score: evaluation.score,\n            hasFollowUp: !!evaluation.followUp,\n          },\n          \"Answer evaluated and saved\"\n        );\n      } catch (evalError) {\n        socketLogger.error({ error: evalError }, \"Error evaluating answer\");\n        // Continue even if evaluation fails\n        evaluation = null;\n      }\n\n      // Handle follow-up or next question\n      if (evaluation?.followUp) {\n        // Move to next question index\n        await transitionSession(activeSession, \"NEXT_QUESTION\");\n        await activeSession.save({ session });\n\n        // Add follow-up question\n        activeSession.questions.push({\n          text: evaluation.followUp,\n          category: \"follow-up\",\n          difficulty: answeredQuestion.difficulty,\n          askedAt: new Date(),\n        });\n        await activeSession.save({ session });\n      } else {\n        // Move to next question\n        await transitionSession(activeSession, \"NEXT_QUESTION\");\n        await activeSession.save({ session });\n      }\n\n      // Check if we need to generate new question\n      const nextQuestionIndex = activeSession.currentQuestionIndex;\n      let nextQuestion = activeSession.questions[nextQuestionIndex];\n\n      if (!nextQuestion) {\n        socketLogger.debug(\"Generating next question\");\n\n        try {\n          const generatedQuestion = await generateNextQuestion(\n            activeSession,\n            userId\n          );\n\n          activeSession.questions.push({\n            text: generatedQuestion.question,\n            category: generatedQuestion.category,\n            difficulty: generatedQuestion.difficulty,\n            askedAt: new Date(),\n          });\n          await activeSession.save({ session });\n\n          // Reload to get the new question\n          await activeSession.populate(\"questions\");\n          nextQuestion = activeSession.questions[nextQuestionIndex];\n        } catch (error) {\n          socketLogger.error({ error }, \"Error generating next question\");\n          await session.abortTransaction();\n          socket.emit(SOCKET_EVENTS.ERROR, {\n            message: \"Failed to generate next question\",\n          });\n          return;\n        }\n      }\n\n      // Update state to waiting for answer\n      activeSession.state = SESSION_STATES.WAITING_FOR_ANSWER;\n      await activeSession.save({ session });\n\n      // Commit transaction\n      await session.commitTransaction();\n\n      // Update cache\n      const updatedSession = await InterviewSession.findById(sessionId).lean();\n      await cacheSession(sessionId, updatedSession);\n\n      // Send next question\n      if (nextQuestion) {\n        // Check if interview should end naturally (reached max questions)\n        const totalQuestions = activeSession.questions.length;\n        if (totalQuestions >= INTERVIEW_LIMITS.MAX_QUESTIONS) {\n          socketLogger.info(\n            \"Interview reached maximum questions, ending naturally\"\n          );\n\n          // Commit transaction before ending\n          await session.commitTransaction();\n          session.endSession();\n\n          // End the session\n          await endInterviewSession(\n            socket,\n            sessionId,\n            userId,\n            sessionMutex,\n            socketLogger\n          );\n          return;\n        }\n\n        await sendQuestionWithTTS(\n          socket,\n          nextQuestion,\n          activeSession.toObject(),\n          sessionId\n        );\n\n        // Reset answer timeout\n        setAnswerTimeout(\n          socket,\n          sessionId,\n          activeSession.language || \"en\",\n          socketLogger\n        );\n      } else {\n        socket.emit(SOCKET_EVENTS.ERROR, {\n          message: \"Failed to get next question\",\n        });\n      }\n    } catch (error) {\n      await session.abortTransaction();\n      throw error;\n    } finally {\n      session.endSession();\n    }\n  }\n\n  /**\n   * End interview session\n   */\n  async function endInterviewSession(\n    socket,\n    sessionId,\n    userId,\n    sessionMutex,\n    socketLogger\n  ) {\n    await sessionMutex.runExclusive(async () => {\n      try {\n        const session = await InterviewSession.findById(sessionId);\n        if (!session || session.status === \"completed\") {\n          socket.emit(SOCKET_EVENTS.ERROR, {\n            message: \"Session already completed or not found\",\n          });\n          return;\n        }\n\n        // End the session using FSM\n        await transitionSession(session, \"END\");\n\n        // Reload session to get latest data\n        const updatedSession = await InterviewSession.findById(\n          sessionId\n        ).lean();\n\n        // Generate and send overall feedback\n        try {\n          const overallFeedback = await generateOverallFeedback(\n            updatedSession,\n            userId,\n            session.language || \"en\"\n          );\n\n          // Send overall feedback to client\n          socket.emit(SOCKET_EVENTS.FINAL_FEEDBACK, {\n            overallScore: overallFeedback.overallScore,\n            summary: overallFeedback.summary,\n            strengths: overallFeedback.strengths,\n            weaknesses: overallFeedback.weaknesses,\n            recommendations: overallFeedback.recommendations,\n            detailedFeedback: overallFeedback.detailedFeedback,\n          });\n\n          socketLogger.info(\n            { overallScore: overallFeedback.overallScore },\n            \"Overall feedback sent\"\n          );\n        } catch (error) {\n          socketLogger.error({ error }, \"Error generating overall feedback\");\n          // Continue without feedback\n        }\n\n        // Invalidate cache\n        await invalidateSessionCache(sessionId);\n\n        // Cleanup resources\n        cleanupSessionResources(sessionId, socket.id);\n\n        // Generate personalized farewell message from LLM\n        let endMessage;\n        try {\n          endMessage = await generateFarewellMessage(\n            userId,\n            session,\n            session.language || \"en\",\n            session.interviewerStyle || \"technical\"\n          );\n\n          socket.emit(SOCKET_EVENTS.MESSAGE, {\n            type: \"system\",\n            text: endMessage,\n          });\n\n          // Queue TTS for end message\n          queueTTS(\n            socket,\n            endMessage,\n            session.voice || \"alloy\",\n            session.language || \"en\",\n            { sessionId, type: \"end\" }\n          );\n        } catch (error) {\n          socketLogger.error({ error }, \"Error generating farewell message\");\n          // Fallback to default message\n          endMessage =\n            session.language === \"ar\"\n              ? \"ØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù…Ù‚Ø§Ø¨Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­. Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ!\"\n              : \"Interview ended successfully. Thank you!\";\n          socket.emit(SOCKET_EVENTS.MESSAGE, {\n            type: \"system\",\n            text: endMessage,\n          });\n          queueTTS(\n            socket,\n            endMessage,\n            session.voice || \"alloy\",\n            session.language || \"en\",\n            { sessionId, type: \"end\" }\n          );\n        }\n\n        // Send ended event (use endMessage or fallback)\n        const finalEndMessage =\n          endMessage ||\n          (session.language === \"ar\"\n            ? \"ØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù…Ù‚Ø§Ø¨Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­. Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ!\"\n            : \"Interview ended successfully. Thank you!\");\n\n        socket.emit(SOCKET_EVENTS.ENDED, {\n          message: finalEndMessage,\n          sessionId: sessionId.toString(),\n          endedAt: session.endedAt,\n        });\n\n        socketLogger.info(\"Interview session ended by user\");\n\n        // Disconnect socket after a short delay to allow TTS to be sent\n        setTimeout(() => {\n          socket.disconnect();\n        }, 2000);\n      } catch (error) {\n        socketLogger.error({ error }, \"Error ending interview\");\n        socket.emit(SOCKET_EVENTS.ERROR, {\n          message: \"Failed to end interview session\",\n        });\n      }\n    });\n  }\n\n  /**\n   * Handle disconnect\n   */\n  async function handleDisconnect(\n    socket,\n    sessionId,\n    userId,\n    sessionMutex,\n    socketLogger\n  ) {\n    socketLogger.info(\"Interview socket disconnected\");\n\n    try {\n      // Cleanup resources\n      cleanupSessionResources(sessionId, socket.id);\n\n      // Update session state if needed\n      await sessionMutex.runExclusive(async () => {\n        const session = await InterviewSession.findById(sessionId);\n        if (session && session.status === \"active\") {\n          // Optionally pause session instead of ending it\n          // session.status = \"paused\";\n          // await session.save();\n        }\n      });\n\n      // Invalidate cache\n      await invalidateSessionCache(sessionId);\n    } catch (error) {\n      socketLogger.error({ error }, \"Error during disconnect cleanup\");\n    }\n  }\n}\n",
      "interview.stt.js": "import OpenAI from \"openai\";\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport os from \"os\";\r\nimport { randomUUID } from \"crypto\";\r\nimport { VALIDATION_LIMITS, TIMEOUTS } from \"./interview.constants.js\";\r\nimport logger from \"../../utils/logger.js\";\r\n\r\nconst openai = new OpenAI({\r\n  apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\nexport async function speechToText(audioBuffer, mimeType) {\r\n  // Validate audio buffer size\r\n  if (!audioBuffer || audioBuffer.length === 0) {\r\n    throw new Error(\"Audio buffer is empty\");\r\n  }\r\n\r\n  if (audioBuffer.length > VALIDATION_LIMITS.MAX_AUDIO_SIZE) {\r\n    throw new Error(\r\n      `Audio size exceeds limit of ${VALIDATION_LIMITS.MAX_AUDIO_SIZE / 1024 / 1024}MB`\r\n    );\r\n  }\r\n\r\n  // 1. Determine file extension\r\n  const ext =\r\n    mimeType === \"audio/webm\"\r\n      ? \"webm\"\r\n      : mimeType === \"audio/wav\"\r\n      ? \"wav\"\r\n      : mimeType === \"audio/m4a\"\r\n      ? \"m4a\"\r\n      : mimeType === \"audio/ogg\"\r\n      ? \"ogg\"\r\n      : \"mp3\";\r\n\r\n  // Use os.tmpdir() for cross-platform compatibility\r\n  const tempDir = os.tmpdir();\r\n  const tempPath = path.join(tempDir, `${randomUUID()}.${ext}`);\r\n  \r\n  let fileExists = false;\r\n\r\n  try {\r\n    // Write temporary file\r\n    fs.writeFileSync(tempPath, audioBuffer);\r\n    fileExists = true;\r\n\r\n    // Set timeout for STT processing\r\n    const timeoutPromise = new Promise((_, reject) => {\r\n      setTimeout(\r\n        () => reject(new Error(\"STT processing timeout\")),\r\n        TIMEOUTS.STT_PROCESSING_TIMEOUT\r\n      );\r\n    });\r\n\r\n    // 2. Whisper call with timeout\r\n    const transcriptionPromise = openai.audio.transcriptions.create({\r\n      file: fs.createReadStream(tempPath),\r\n      model: \"whisper-1\",\r\n      response_format: \"verbose_json\",\r\n    });\r\n\r\n    const transcription = await Promise.race([\r\n      transcriptionPromise,\r\n      timeoutPromise,\r\n    ]);\r\n\r\n    return transcription.text;\r\n  } catch (error) {\r\n    logger.error({ error, mimeType, size: audioBuffer.length }, \"STT processing error\");\r\n    throw error;\r\n  } finally {\r\n    // Cleanup: delete temporary file\r\n    if (fileExists) {\r\n      try {\r\n        if (fs.existsSync(tempPath)) {\r\n          fs.unlinkSync(tempPath);\r\n        }\r\n      } catch (cleanupError) {\r\n        logger.error({ error: cleanupError, tempPath }, \"Failed to cleanup temp file\");\r\n      }\r\n    }\r\n  }\r\n}\r\n",
      "interview.tts.js": "import OpenAI from \"openai\";\r\n\r\nconst openai = new OpenAI({\r\n  apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\n/**\r\n * Valid OpenAI TTS voices\r\n */\r\nconst VALID_VOICES = [\r\n  \"nova\",\r\n  \"shimmer\",\r\n  \"echo\",\r\n  \"onyx\",\r\n  \"fable\",\r\n  \"alloy\",\r\n  \"ash\",\r\n  \"sage\",\r\n  \"coral\",\r\n];\r\n\r\n/**\r\n * Get valid voice or return default\r\n */\r\nfunction getValidVoice(voice, language) {\r\n  // If voice is valid, use it\r\n  if (voice && VALID_VOICES.includes(voice.toLowerCase())) {\r\n    return voice.toLowerCase();\r\n  }\r\n\r\n  // Default based on language\r\n  if (language === \"ar\") {\r\n    return \"echo\"; // Good for Arabic\r\n  }\r\n\r\n  return \"alloy\"; // Default English voice\r\n}\r\n\r\n/**\r\n * Convert text to speech\r\n */\r\nexport async function textToSpeech({ text, voice, language }) {\r\n  const validVoice = getValidVoice(voice, language);\r\n\r\n  const response = await openai.audio.speech.create({\r\n    model: \"tts-1\",\r\n    voice: validVoice,\r\n    input: text,\r\n    format: \"mp3\",\r\n  });\r\n\r\n  // Convert stream â†’ Buffer\r\n  const buffer = Buffer.from(await response.arrayBuffer());\r\n\r\n  return buffer;\r\n}\r\n",
      "interview.tts.queue.js": "import { textToSpeech } from \"./interview.tts.js\";\r\nimport { TIMEOUTS } from \"./interview.constants.js\";\r\nimport logger from \"../../utils/logger.js\";\r\n\r\n/**\r\n * TTS Queue Handler\r\n * Processes TTS requests asynchronously to avoid blocking\r\n */\r\n\r\n/**\r\n * Process TTS request and emit to socket\r\n * @param {Object} socket - Socket.IO socket instance\r\n * @param {string} text - Text to convert to speech\r\n * @param {string} voice - Voice to use\r\n * @param {string} language - Language code\r\n * @param {Object} context - Additional context for logging\r\n * @returns {Promise<void>}\r\n */\r\nexport async function queueTTS(socket, text, voice, language, context = {}) {\r\n  // Process TTS asynchronously without blocking\r\n  (async () => {\r\n    try {\r\n      const log = logger.child({ ...context, text: text.substring(0, 50) });\r\n      log.debug(\"Generating TTS\");\r\n\r\n      // Set timeout for TTS generation\r\n      const timeoutPromise = new Promise((_, reject) => {\r\n        setTimeout(\r\n          () => reject(new Error(\"TTS generation timeout\")),\r\n          TIMEOUTS.TTS_GENERATION_TIMEOUT\r\n        );\r\n      });\r\n\r\n      // Generate TTS with timeout\r\n      const audioBuffer = await Promise.race([\r\n        textToSpeech({ text, voice, language }),\r\n        timeoutPromise,\r\n      ]);\r\n\r\n      // Emit TTS to client\r\n      socket.emit(\"interview:tts\", {\r\n        audio: audioBuffer.toString(\"base64\"),\r\n        mimeType: \"audio/mpeg\",\r\n      });\r\n\r\n      log.debug(\"TTS generated and sent\");\r\n    } catch (error) {\r\n      const log = logger.child({ ...context, error });\r\n      log.error(\"Error generating TTS\");\r\n      \r\n      // Emit error to client (optional - can be silent)\r\n      socket.emit(\"interview:tts-error\", {\r\n        message: \"Failed to generate audio\",\r\n        text: text.substring(0, 100), // Send partial text for context\r\n      });\r\n    }\r\n  })();\r\n}\r\n\r\n/**\r\n * Process multiple TTS requests in sequence\r\n * @param {Object} socket - Socket.IO socket instance\r\n * @param {Array<{text: string, voice?: string, language?: string}>} texts - Array of texts to convert\r\n * @param {string} defaultVoice - Default voice to use\r\n * @param {string} defaultLanguage - Default language to use\r\n * @param {Object} context - Additional context for logging\r\n * @returns {Promise<void>}\r\n */\r\nexport async function queueMultipleTTS(\r\n  socket,\r\n  texts,\r\n  defaultVoice,\r\n  defaultLanguage,\r\n  context = {}\r\n) {\r\n  for (const item of texts) {\r\n    await queueTTS(\r\n      socket,\r\n      item.text,\r\n      item.voice || defaultVoice,\r\n      item.language || defaultLanguage,\r\n      { ...context, sequence: true }\r\n    );\r\n    // Small delay between TTS generations to avoid overwhelming\r\n    await new Promise((resolve) => setTimeout(resolve, 100));\r\n  }\r\n}\r\n\r\n"
    },
    "llm": {
      "rag.controller.js": "import asyncHandler from \"express-async-handler\";\r\nimport { askQuestion } from \"./rag.service.js\";\r\nimport { AppError } from \"../../utils/AppError.js\";\r\n\r\nexport const ask = asyncHandler(async (req, res) => {\r\n  const question = req.body.question || req.body.q;\r\n\r\n  if (!question) {\r\n    throw new AppError(\"Question is required in request body\", 400);\r\n  }\r\n\r\n  // Get userId from req.user (assuming you'll add auth middleware)\r\n  const userId = req.user?._id || req.user?.id;\r\n  if (!userId) {\r\n    throw new AppError(\"User not authenticated\", 401);\r\n  }\r\n\r\n  const answer = await askQuestion(question, userId);\r\n  res.json({\r\n    status: \"success\",\r\n    data: { answer },\r\n  });\r\n});\r\n",
      "rag.routes.js": "import { Router } from \"express\";\r\nimport { ask } from \"./rag.controller.js\";\r\nimport { protect } from \"../../middleware/auth.middleware.js\";\r\n\r\nconst router = Router();\r\nrouter.post(\"/\", protect, ask);\r\nexport default router;\r\n",
      "rag.service.js": "import { queryDocuments } from \"../vector/vector.service.js\";\r\nimport { ChatOpenAI } from \"@langchain/openai\";\r\nimport { AppError } from \"../../utils/AppError.js\";\r\nimport User from \"../auth/user.model.js\";\r\n\r\nconst openai = new ChatOpenAI({\r\n  apiKey: process.env.OPENAI_API_KEY,\r\n  model: \"gpt-4o-mini\",\r\n});\r\n\r\nconst structuredOpenAI = new ChatOpenAI({\r\n  apiKey: process.env.OPENAI_API_KEY,\r\n  model: \"gpt-4o\", // or \"gpt-4o-mini\" if you want to save costs\r\n  temperature: 0,\r\n});\r\n\r\nexport async function askQuestion(question, userId) {\r\n  if (!question || question.trim().length === 0) {\r\n    throw new AppError(\"Question cannot be empty\", 400);\r\n  }\r\n\r\n  const vector = await queryDocuments(question, userId);\r\n  const documents = vector.documents[0] || [];\r\n\r\n  if (documents.length === 0) {\r\n    throw new AppError(\"No relevant documents found for your question\", 404);\r\n  }\r\n\r\n  const context = documents.join(\"\\n\");\r\n  const prompt = `Answer based on context only:\\n${context}\\nQuestion: ${question}`;\r\n\r\n  const response = await openai.invoke(prompt);\r\n  return response.content;\r\n}\r\n"
    },
    "upload": {
      "cv-upload-job.model.js": "import mongoose from \"mongoose\";\r\n\r\nconst cvUploadJobSchema = new mongoose.Schema(\r\n  {\r\n    userId: {\r\n      type: mongoose.Schema.Types.ObjectId,\r\n      ref: \"User\",\r\n      required: true,\r\n      index: true,\r\n    },\r\n    status: {\r\n      type: String,\r\n      enum: [\"pending\", \"processing\", \"completed\", \"failed\", \"cancelled\"],\r\n      default: \"pending\",\r\n      index: true,\r\n    },\r\n    progress: {\r\n      type: Number,\r\n      default: 0,\r\n      min: 0,\r\n      max: 100,\r\n    },\r\n    fileInfo: {\r\n      fileName: {\r\n        type: String,\r\n        required: true,\r\n      },\r\n      fileType: {\r\n        type: String,\r\n        enum: [\"pdf\", \"docx\", \"doc\"],\r\n        required: true,\r\n      },\r\n      mimeType: {\r\n        type: String,\r\n        required: true,\r\n      },\r\n      fileSize: {\r\n        type: Number,\r\n        required: true,\r\n      },\r\n    },\r\n    fileBuffer: {\r\n      type: Buffer,\r\n      required: true,\r\n    },\r\n    result: {\r\n      stored: Number,\r\n      ids: [String],\r\n      atsScore: {\r\n        score: Number,\r\n        feedback: {\r\n          strengths: [String],\r\n          weaknesses: [String],\r\n          recommendations: [String],\r\n        },\r\n        breakdown: {\r\n          formatting: Number,\r\n          keywords: Number,\r\n          contact: Number,\r\n          experience: Number,\r\n          education: Number,\r\n          sections: Number,\r\n          atsCompatibility: Number,\r\n        },\r\n        analyzedAt: Date,\r\n      },\r\n      personalInformation: {\r\n        fullName: String,\r\n        email: String,\r\n        phone: String,\r\n        location: String,\r\n        linkedin: String,\r\n        github: String,\r\n        portfolio: String,\r\n        summary: String,\r\n      },\r\n      technicalSkills: [String],\r\n      yearsOfExperience: Number,\r\n      education: [\r\n        {\r\n          degree: String,\r\n          field: String,\r\n          institution: String,\r\n          location: String,\r\n          startDate: String,\r\n          endDate: String,\r\n          gpa: String,\r\n          honors: String,\r\n        },\r\n      ],\r\n    },\r\n    error: {\r\n      message: String,\r\n      stack: String,\r\n    },\r\n    retryCount: {\r\n      type: Number,\r\n      default: 0,\r\n    },\r\n    startedAt: Date,\r\n    completedAt: Date,\r\n  },\r\n  { timestamps: true }\r\n);\r\n\r\n// Indexes for efficient queries\r\ncvUploadJobSchema.index({ userId: 1, createdAt: -1 });\r\ncvUploadJobSchema.index({ status: 1, createdAt: -1 });\r\n\r\nconst CVUploadJob = mongoose.model(\"CVUploadJob\", cvUploadJobSchema);\r\n\r\nexport default CVUploadJob;\r\n\r\n",
      "upload.controller.js": "import asyncHandler from \"express-async-handler\";\r\nimport { AppError } from \"../../utils/AppError.js\";\r\nimport User from \"../auth/user.model.js\";\r\nimport CVUploadJob from \"./cv-upload-job.model.js\";\r\nimport { addCVUploadJob } from \"./upload.queue.js\";\r\nimport { getVectorStore } from \"../vector/chroma.client.js\";\r\n\r\nexport const uploadDocument = asyncHandler(async (req, res) => {\r\n  if (!req.file) {\r\n    throw new AppError(\"No file provided\", 400);\r\n  }\r\n\r\n  // Get userId from req.user\r\n  const userId = req.user?._id;\r\n  const user = await User.findById(userId);\r\n  if (!user) {\r\n    throw new AppError(\"User not found\", 404);\r\n  }\r\n\r\n  const mimeType = req.file.mimetype;\r\n  const fileName = req.file.originalname;\r\n  const fileBuffer = req.file.buffer;\r\n\r\n  // Determine file type\r\n  let fileType;\r\n  if (mimeType === \"application/pdf\") {\r\n    fileType = \"pdf\";\r\n  } else if (\r\n    mimeType ===\r\n      \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" ||\r\n    mimeType === \"application/msword\"\r\n  ) {\r\n    fileType = mimeType.includes(\"openxml\") ? \"docx\" : \"doc\";\r\n  } else {\r\n    throw new AppError(`Unsupported file type: ${mimeType}`, 400);\r\n  }\r\n\r\n  // Save current document data before deleting (to return in response)\r\n  const currentDocumentData =\r\n    user.document && user.document.fileName\r\n      ? {\r\n          fileName: user.document.fileName,\r\n          fileType: user.document.fileType,\r\n          uploadedAt: user.document.uploadedAt,\r\n          atsScore: user.document.atsScore,\r\n          personalInformation: user.document.personalInformation,\r\n          technicalSkills: user.document.technicalSkills,\r\n          yearsOfExperience: user.document.yearsOfExperience,\r\n          education: user.document.education,\r\n        }\r\n      : null;\r\n\r\n  // Delete old CV if exists (user can only have one CV)\r\n  if (\r\n    user.document &&\r\n    user.document.chunksIds &&\r\n    user.document.chunksIds.length > 0\r\n  ) {\r\n    try {\r\n      // Delete old chunks from vector store\r\n      const vectorStore = await getVectorStore();\r\n      await vectorStore.delete({ ids: user.document.chunksIds });\r\n    } catch (error) {\r\n      console.error(\"Error deleting old document chunks:\", error);\r\n      // Continue even if deletion fails\r\n    }\r\n\r\n    // Clear old document from user\r\n    await user.clearDocument();\r\n  }\r\n\r\n  // Cancel/delete any pending or processing jobs for this user\r\n  await CVUploadJob.updateMany(\r\n    {\r\n      userId,\r\n      status: { $in: [\"pending\", \"processing\"] },\r\n    },\r\n    {\r\n      status: \"cancelled\",\r\n      error: {\r\n        message: \"Cancelled due to new CV upload\",\r\n      },\r\n      completedAt: new Date(),\r\n    }\r\n  );\r\n\r\n  // Create job record in MongoDB first (Single Source of Truth)\r\n  const job = await CVUploadJob.create({\r\n    userId,\r\n    status: \"pending\",\r\n    progress: 0,\r\n    fileInfo: {\r\n      fileName,\r\n      fileType,\r\n      mimeType,\r\n      fileSize: fileBuffer.length,\r\n    },\r\n    fileBuffer,\r\n  });\r\n\r\n  // Add job ID to BullMQ queue for processing\r\n  await addCVUploadJob(job._id, userId);\r\n\r\n  res.json({\r\n    status: \"success\",\r\n    message: \"CV upload job created. Processing will start shortly.\",\r\n    data: {\r\n      jobId: job._id.toString(),\r\n      status: job.status,\r\n      progress: job.progress,\r\n      // Return previous document data (will be updated when new job completes)\r\n      document: currentDocumentData,\r\n    },\r\n  });\r\n});\r\n\r\nexport const getJobStatus = asyncHandler(async (req, res) => {\r\n  const { jobId } = req.params;\r\n  const userId = req.user?._id;\r\n\r\n  // Read status from MongoDB (Single Source of Truth), not BullMQ\r\n  const job = await CVUploadJob.findOne({\r\n    _id: jobId,\r\n    userId,\r\n  });\r\n\r\n  if (!job) {\r\n    throw new AppError(\"Job not found\", 404);\r\n  }\r\n\r\n  res.json({\r\n    status: \"success\",\r\n    data: {\r\n      jobId: job._id.toString(),\r\n      status: job.status,\r\n      progress: job.progress,\r\n      fileInfo: {\r\n        fileName: job.fileInfo.fileName,\r\n        fileType: job.fileInfo.fileType,\r\n      },\r\n      result: job.result || undefined,\r\n      error: job.error || undefined,\r\n      startedAt: job.startedAt,\r\n      completedAt: job.completedAt,\r\n      createdAt: job.createdAt,\r\n      updatedAt: job.updatedAt,\r\n    },\r\n  });\r\n});\r\n\r\n/**\r\n * Get current user's CV document data\r\n * GET /upload-pdf/document\r\n */\r\nexport const getCurrentDocument = asyncHandler(async (req, res) => {\r\n  const userId = req.user?._id;\r\n  const user = await User.findById(userId).select(\"document\");\r\n\r\n  if (!user) {\r\n    throw new AppError(\"User not found\", 404);\r\n  }\r\n\r\n  // Check if user has a document\r\n  if (!user.document || !user.document.fileName) {\r\n    return res.json({\r\n      status: \"success\",\r\n      data: {\r\n        document: null,\r\n        message: \"No CV uploaded yet\",\r\n      },\r\n    });\r\n  }\r\n\r\n  // Return document data from MongoDB (Single Source of Truth)\r\n  res.json({\r\n    status: \"success\",\r\n    data: {\r\n      document: {\r\n        fileName: user.document.fileName,\r\n        fileType: user.document.fileType,\r\n        uploadedAt: user.document.uploadedAt,\r\n        totalChunks: user.document.totalChunks,\r\n        atsScore: user.document.atsScore,\r\n        personalInformation: user.document.personalInformation,\r\n        technicalSkills: user.document.technicalSkills,\r\n        yearsOfExperience: user.document.yearsOfExperience,\r\n        education: user.document.education,\r\n      },\r\n    },\r\n  });\r\n});\r\n\r\nexport const uploadPDF = uploadDocument;\r\n",
      "upload.queue.js": "import { Queue } from \"bullmq\";\r\nimport { getRedisConnection } from \"../../config/redis.js\";\r\n\r\n// Redis connection configuration (supports Redis Cloud)\r\nconst connection = getRedisConnection();\r\n\r\n// Create BullMQ queue instance\r\n// This queue only stores job ID references, not full state\r\nexport const cvUploadQueue = new Queue(\"cv-upload\", {\r\n  connection,\r\n  defaultJobOptions: {\r\n    attempts: 3,\r\n    backoff: {\r\n      type: \"exponential\",\r\n      delay: 2000,\r\n    },\r\n    removeOnComplete: {\r\n      age: 24 * 3600, // Keep completed jobs for 24 hours\r\n      count: 1000, // Keep max 1000 completed jobs\r\n    },\r\n    removeOnFail: {\r\n      age: 7 * 24 * 3600, // Keep failed jobs for 7 days\r\n    },\r\n  },\r\n});\r\n\r\n// Helper function to add job to queue\r\n// Job data only contains MongoDB job ID reference\r\nexport async function addCVUploadJob(jobId, userId) {\r\n  return await cvUploadQueue.add(\"process-cv\", {\r\n    jobId: jobId.toString(),\r\n    userId: userId.toString(),\r\n  });\r\n}\r\n\r\n// Helper function to get job from queue (for reference only)\r\nexport async function getQueueJob(bullmqJobId) {\r\n  return await cvUploadQueue.getJob(bullmqJobId);\r\n}\r\n\r\nexport default cvUploadQueue;\r\n",
      "upload.routes.js": "import { Router } from \"express\";\r\nimport { uploadMemory } from \"../../middleware/upload.middleware.js\";\r\nimport {\r\n  uploadDocument,\r\n  getJobStatus,\r\n  getCurrentDocument,\r\n} from \"./upload.controller.js\";\r\nimport { protect } from \"../../middleware/auth.middleware.js\";\r\n\r\nconst router = Router();\r\n\r\n// Upload CV\r\nrouter.post(\"/\", protect, uploadMemory, uploadDocument);\r\n\r\n// Get job status\r\nrouter.get(\"/status/:jobId\", protect, getJobStatus);\r\n\r\n// Get current user's CV document data\r\nrouter.get(\"/document\", protect, getCurrentDocument);\r\n\r\nexport default router;\r\n",
      "upload.service.js": "import { PDFLoader } from \"@langchain/community/document_loaders/fs/pdf\";\r\nimport { DocxLoader } from \"@langchain/community/document_loaders/fs/docx\";\r\nimport { RecursiveCharacterTextSplitter } from \"@langchain/textsplitters\";\r\nimport { getVectorStore } from \"../vector/chroma.client.js\";\r\nimport { AppError } from \"../../utils/AppError.js\";\r\nimport User from \"../auth/user.model.js\";\r\nimport { analyzeCV } from \"../cv-analysis/cv-analysis.service.js\";\r\n\r\n// Delete old document chunks from Pinecone\r\nasync function deleteUserDocument(userId, chunkIds) {\r\n  if (!chunkIds || chunkIds.length === 0) return;\r\n\r\n  try {\r\n    const vectorStore = await getVectorStore();\r\n    await vectorStore.delete({ ids: chunkIds });\r\n  } catch (error) {\r\n    // Don't throw - continue with upload even if deletion fails\r\n  }\r\n}\r\n\r\n// Generic function to process any document buffer\r\nasync function processDocumentBuffer(fileBuffer, fileType, userId, fileName) {\r\n  let loader;\r\n  const mimeType =\r\n    fileType === \"pdf\"\r\n      ? \"application/pdf\"\r\n      : \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\";\r\n  const blob = new Blob([fileBuffer], { type: mimeType });\r\n\r\n  // Choose loader based on file type\r\n  if (fileType === \"pdf\") {\r\n    loader = new PDFLoader(blob);\r\n  } else if (fileType === \"docx\" || fileType === \"doc\") {\r\n    loader = new DocxLoader(blob, { type: fileType });\r\n  } else {\r\n    throw new AppError(`Unsupported file type: ${fileType}`, 400);\r\n  }\r\n\r\n  // Load document content\r\n  const docs = await loader.load();\r\n\r\n  // Split into chunks\r\n  const splitter = new RecursiveCharacterTextSplitter({\r\n    chunkSize: 1000,\r\n    chunkOverlap: 150,\r\n  });\r\n\r\n  const chunks = await splitter.splitDocuments(docs);\r\n\r\n  // Get user to check for existing document\r\n  const user = await User.findById(userId);\r\n  if (!user) {\r\n    throw new AppError(\"User not found\", 404);\r\n  }\r\n\r\n  // Delete old document if exists\r\n  if (user.document && user.document.chunksIds.length > 0) {\r\n    await deleteUserDocument(userId, user.document.chunksIds);\r\n  }\r\n\r\n  // Store in Pinecone with user-specific IDs and metadata\r\n  const vectorStore = await getVectorStore();\r\n  const timestamp = Date.now();\r\n  const ids = chunks.map((_, i) => `user_${userId}_${timestamp}_${i}`);\r\n\r\n  // Add metadata to each chunk for Pinecone native metadata filtering\r\n  const chunksWithMetadata = chunks.map((chunk) => ({\r\n    ...chunk,\r\n    metadata: {\r\n      ...chunk.metadata,\r\n      userId: userId.toString(),\r\n      docType: \"cv\",\r\n    },\r\n  }));\r\n\r\n  const storedIds = await vectorStore.addDocuments(chunksWithMetadata, { ids });\r\n\r\n  // Update user document info\r\n  await user.updateDocument(storedIds, fileName, fileType);\r\n\r\n  let cvAnalysis = null;\r\n  try {\r\n    cvAnalysis = await analyzeCV(fileBuffer, fileType);\r\n\r\n    // Update user with all CV analysis data\r\n    user.document.atsScore = cvAnalysis.atsScore;\r\n    user.document.personalInformation = cvAnalysis.personalInformation;\r\n\r\n    // Ensure technicalSkills is always an array of strings\r\n    if (Array.isArray(cvAnalysis.technicalSkills)) {\r\n      user.document.technicalSkills = cvAnalysis.technicalSkills\r\n        .filter(\r\n          (skill) =>\r\n            skill !== null && skill !== undefined && typeof skill === \"string\"\r\n        )\r\n        .map((skill) => String(skill).trim())\r\n        .filter((skill) => skill.length > 0);\r\n    } else {\r\n      user.document.technicalSkills = [];\r\n    }\r\n\r\n    user.document.yearsOfExperience = cvAnalysis.yearsOfExperience || null;\r\n    user.document.education = cvAnalysis.education;\r\n    await user.save();\r\n  } catch (error) {\r\n    // Don't fail the upload if analysis fails\r\n  }\r\n\r\n  return {\r\n    stored: chunks.length,\r\n    ids: storedIds,\r\n    fileType,\r\n    fileName,\r\n    atsScore: cvAnalysis?.atsScore,\r\n    personalInformation: cvAnalysis?.personalInformation,\r\n    technicalSkills: cvAnalysis?.technicalSkills,\r\n    yearsOfExperience: cvAnalysis?.yearsOfExperience,\r\n    education: cvAnalysis?.education,\r\n  };\r\n}\r\n\r\n// Generic function that auto-detects file type\r\nexport async function processDocument(fileBuffer, mimeType, userId, fileName) {\r\n  let fileType;\r\n\r\n  if (mimeType === \"application/pdf\") {\r\n    fileType = \"pdf\";\r\n  } else if (\r\n    mimeType ===\r\n      \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" ||\r\n    mimeType === \"application/msword\"\r\n  ) {\r\n    fileType = mimeType.includes(\"openxml\") ? \"docx\" : \"doc\";\r\n  } else {\r\n    throw new AppError(`Unsupported file type: ${mimeType}`, 400);\r\n  }\r\n\r\n  return await processDocumentBuffer(fileBuffer, fileType, userId, fileName);\r\n}\r\n",
      "upload.worker.js": "import { Worker } from \"bullmq\";\r\nimport { getRedisConnection } from \"../../config/redis.js\";\r\nimport CVUploadJob from \"./cv-upload-job.model.js\";\r\nimport User from \"../auth/user.model.js\";\r\nimport { PDFLoader } from \"@langchain/community/document_loaders/fs/pdf\";\r\nimport { DocxLoader } from \"@langchain/community/document_loaders/fs/docx\";\r\nimport { RecursiveCharacterTextSplitter } from \"@langchain/textsplitters\";\r\nimport { getVectorStore } from \"../vector/chroma.client.js\";\r\nimport { analyzeCV } from \"../cv-analysis/cv-analysis.service.js\";\r\nimport { AppError } from \"../../utils/AppError.js\";\r\n\r\n// Redis connection configuration (supports Redis Cloud)\r\nconst connection = getRedisConnection();\r\n\r\n// Delete old document chunks from Pinecone\r\nasync function deleteUserDocument(userId, chunkIds) {\r\n  if (!chunkIds || chunkIds.length === 0) return;\r\n\r\n  try {\r\n    const vectorStore = await getVectorStore();\r\n    await vectorStore.delete({ ids: chunkIds });\r\n  } catch (error) {\r\n    // Don't throw - continue with upload even if deletion fails\r\n    console.error(\"Error deleting old document chunks:\", error);\r\n  }\r\n}\r\n\r\n// Process CV upload job\r\nasync function processCVUploadJob(jobData) {\r\n  const { jobId, userId } = jobData;\r\n\r\n  // Read job state from MongoDB (Single Source of Truth)\r\n  const job = await CVUploadJob.findById(jobId);\r\n  if (!job) {\r\n    throw new AppError(`Job ${jobId} not found in MongoDB`, 404);\r\n  }\r\n\r\n  // Check if job is already completed or failed\r\n  if (job.status === \"completed\") {\r\n    return;\r\n  }\r\n\r\n  if (job.status === \"failed\") {\r\n    return;\r\n  }\r\n\r\n  try {\r\n    // Update job status to processing\r\n    job.status = \"processing\";\r\n    job.startedAt = new Date();\r\n    job.progress = 10;\r\n    await job.save();\r\n\r\n    const fileBuffer = job.fileBuffer;\r\n    const fileType = job.fileInfo.fileType;\r\n    const fileName = job.fileInfo.fileName;\r\n\r\n    // Step 1: Load document (20%)\r\n    job.progress = 20;\r\n    await job.save();\r\n\r\n    let loader;\r\n    const mimeType =\r\n      fileType === \"pdf\"\r\n        ? \"application/pdf\"\r\n        : \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\";\r\n    const blob = new Blob([fileBuffer], { type: mimeType });\r\n\r\n    if (fileType === \"pdf\") {\r\n      loader = new PDFLoader(blob);\r\n    } else if (fileType === \"docx\" || fileType === \"doc\") {\r\n      loader = new DocxLoader(blob, { type: fileType });\r\n    } else {\r\n      throw new AppError(`Unsupported file type: ${fileType}`, 400);\r\n    }\r\n\r\n    const docs = await loader.load();\r\n\r\n    // Step 2: Split into chunks (40%)\r\n    job.progress = 40;\r\n    await job.save();\r\n\r\n    const splitter = new RecursiveCharacterTextSplitter({\r\n      chunkSize: 1000,\r\n      chunkOverlap: 150,\r\n    });\r\n\r\n    const chunks = await splitter.splitDocuments(docs);\r\n\r\n    // Step 3: Delete old document if exists (50%)\r\n    job.progress = 50;\r\n    await job.save();\r\n\r\n    const user = await User.findById(userId);\r\n    if (!user) {\r\n      throw new AppError(\"User not found\", 404);\r\n    }\r\n\r\n    if (user.document && user.document.chunksIds.length > 0) {\r\n      await deleteUserDocument(userId, user.document.chunksIds);\r\n    }\r\n\r\n    // Step 4: Store in Pinecone (70%)\r\n    job.progress = 70;\r\n    await job.save();\r\n\r\n    const vectorStore = await getVectorStore();\r\n    const timestamp = Date.now();\r\n    const ids = chunks.map((_, i) => `user_${userId}_${timestamp}_${i}`);\r\n\r\n    // Add metadata to each chunk for Pinecone native metadata filtering\r\n    const chunksWithMetadata = chunks.map((chunk) => ({\r\n      ...chunk,\r\n      metadata: {\r\n        ...chunk.metadata,\r\n        userId: userId.toString(),\r\n        docType: \"cv\",\r\n      },\r\n    }));\r\n\r\n    const storedIds = await vectorStore.addDocuments(chunksWithMetadata, {\r\n      ids,\r\n    });\r\n\r\n    // Step 5: Analyze CV (85%)\r\n    job.progress = 85;\r\n    await job.save();\r\n\r\n    let cvAnalysis = null;\r\n    try {\r\n      cvAnalysis = await analyzeCV(fileBuffer, fileType);\r\n    } catch (error) {\r\n      console.error(\"CV analysis failed:\", error);\r\n      // Continue without analysis\r\n    }\r\n\r\n    // Step 6: Update User document (95%)\r\n    job.progress = 95;\r\n    await job.save();\r\n\r\n    // Update user document info\r\n    await user.updateDocument(storedIds, fileName, fileType);\r\n\r\n    // Update user with CV analysis data if available\r\n    if (cvAnalysis) {\r\n      user.document.atsScore = cvAnalysis.atsScore;\r\n      user.document.personalInformation = cvAnalysis.personalInformation;\r\n\r\n      if (Array.isArray(cvAnalysis.technicalSkills)) {\r\n        user.document.technicalSkills = cvAnalysis.technicalSkills\r\n          .filter(\r\n            (skill) =>\r\n              skill !== null && skill !== undefined && typeof skill === \"string\"\r\n          )\r\n          .map((skill) => String(skill).trim())\r\n          .filter((skill) => skill.length > 0);\r\n      } else {\r\n        user.document.technicalSkills = [];\r\n      }\r\n\r\n      user.document.yearsOfExperience = cvAnalysis.yearsOfExperience || null;\r\n      user.document.education = cvAnalysis.education;\r\n      await user.save();\r\n    }\r\n\r\n    // Step 7: Complete job (100%)\r\n    job.status = \"completed\";\r\n    job.progress = 100;\r\n    job.completedAt = new Date();\r\n    job.result = {\r\n      stored: chunks.length,\r\n      ids: storedIds,\r\n      atsScore: cvAnalysis?.atsScore,\r\n      personalInformation: cvAnalysis?.personalInformation,\r\n      technicalSkills: cvAnalysis?.technicalSkills,\r\n      yearsOfExperience: cvAnalysis?.yearsOfExperience,\r\n      education: cvAnalysis?.education,\r\n    };\r\n    await job.save();\r\n  } catch (error) {\r\n    // Update job status to failed in MongoDB\r\n    job.status = \"failed\";\r\n    job.error = {\r\n      message: error.message || \"Unknown error\",\r\n      stack: error.stack,\r\n    };\r\n    job.completedAt = new Date();\r\n    await job.save();\r\n\r\n    console.error(`Job ${jobId} failed:`, error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Create BullMQ worker\r\nexport const cvUploadWorker = new Worker(\r\n  \"cv-upload\",\r\n  async (job) => {\r\n    const { jobId, userId } = job.data;\r\n\r\n    // Process job - all state updates happen in MongoDB\r\n    await processCVUploadJob({ jobId, userId });\r\n\r\n    return { jobId, status: \"completed\" };\r\n  },\r\n  {\r\n    connection,\r\n    concurrency: 2, // Process 2 jobs concurrently\r\n    limiter: {\r\n      max: 5, // Max 5 jobs per second\r\n      duration: 1000,\r\n    },\r\n  }\r\n);\r\n\r\n// Worker event handlers\r\ncvUploadWorker.on(\"completed\", (job) => {\r\n  console.log(`Job ${job.id} completed`);\r\n});\r\n\r\ncvUploadWorker.on(\"failed\", (job, err) => {\r\n  console.error(`Job ${job?.id} failed:`, err);\r\n\r\n  // Update job status in MongoDB if job data is available\r\n  if (job?.data?.jobId) {\r\n    CVUploadJob.findByIdAndUpdate(\r\n      job.data.jobId,\r\n      {\r\n        status: \"failed\",\r\n        error: {\r\n          message: err.message || \"Unknown error\",\r\n          stack: err.stack,\r\n        },\r\n        completedAt: new Date(),\r\n      },\r\n      { new: true }\r\n    ).catch((error) => {\r\n      console.error(\"Error updating job status in MongoDB:\", error);\r\n    });\r\n  }\r\n});\r\n\r\ncvUploadWorker.on(\"error\", (err) => {\r\n  console.error(\"Worker error:\", err);\r\n});\r\n\r\nexport default cvUploadWorker;\r\n"
    },
    "vector": {
      "chroma.client.js": "import { Pinecone } from \"@pinecone-database/pinecone\";\r\nimport { PineconeStore } from \"@langchain/pinecone\";\r\nimport { OpenAIEmbeddings } from \"@langchain/openai\";\r\nimport { config } from \"../../config/env.js\";\r\nimport { AppError } from \"../../utils/AppError.js\";\r\n\r\n// Initialize Pinecone client\r\nconst pinecone = new Pinecone({\r\n  apiKey: config.pinecone_api_key,\r\n});\r\n\r\n// Get the index\r\nconst index = pinecone.Index(config.pinecone_index_name);\r\n\r\n// Create embeddings function\r\nconst embeddings = new OpenAIEmbeddings({\r\n  apiKey: config.openai_key,\r\n});\r\n\r\n// Get or create the vector store\r\nexport async function getVectorStore() {\r\n  try {\r\n    if (!config.pinecone_api_key) {\r\n      throw new AppError(\"Pinecone API key is not configured\", 500);\r\n    }\r\n    if (!config.openai_key) {\r\n      throw new AppError(\"OpenAI API key is not configured\", 500);\r\n    }\r\n\r\n    return await PineconeStore.fromExistingIndex(embeddings, {\r\n      pineconeIndex: index,\r\n    });\r\n  } catch (error) {\r\n    if (error instanceof AppError) {\r\n      throw error;\r\n    }\r\n    throw new AppError(\r\n      `Failed to connect to vector store: ${error.message}`,\r\n      500\r\n    );\r\n  }\r\n}\r\n",
      "vector.controller.js": "import asyncHandler from \"express-async-handler\";\r\nimport { queryDocuments } from \"./vector.service.js\";\r\nimport { AppError } from \"../../utils/AppError.js\";\r\n\r\nexport const queryVector = asyncHandler(async (req, res) => {\r\n  const { q } = req.query;\r\n\r\n  if (!q) {\r\n    throw new AppError(\"Query parameter 'q' is required\", 400);\r\n  }\r\n\r\n  // Get userId from req.user (assuming you'll add auth middleware)\r\n  const userId = req.user?._id || req.user?.id;\r\n  if (!userId) {\r\n    throw new AppError(\"User not authenticated\", 401);\r\n  }\r\n\r\n  const result = await queryDocuments(q, userId);\r\n  res.json({\r\n    status: \"success\",\r\n    data: result,\r\n  });\r\n});\r\n",
      "vector.routes.js": "import { Router } from \"express\";\r\nimport { queryVector } from \"./vector.controller.js\";\r\nimport { protect } from \"../../middleware/auth.middleware.js\";\r\n\r\nconst router = Router();\r\nrouter.get(\"/\", protect, queryVector);\r\nexport default router;\r\n",
      "vector.service.js": "import { getVectorStore } from \"./chroma.client.js\";\r\nimport User from \"../auth/user.model.js\";\r\nimport { AppError } from \"../../utils/AppError.js\";\r\n\r\nexport async function queryDocuments(query, userId) {\r\n  // Check if user has uploaded CV (validation only)\r\n  const user = await User.findById(userId);\r\n  if (!user) {\r\n    throw new AppError(\"User not found\", 404);\r\n  }\r\n\r\n  if (!user.document || user.document.chunksIds.length === 0) {\r\n    throw new AppError(\r\n      \"No document uploaded yet. Please upload a document first.\",\r\n      404\r\n    );\r\n  }\r\n\r\n  const vectorStore = await getVectorStore();\r\n\r\n  const userIdStr = userId.toString();\r\n\r\n  // Use Pinecone's native metadata filtering with topK\r\n  // No manual filtering needed - Pinecone handles all filtering natively\r\n  const results = await vectorStore.similaritySearch(query, 3, {\r\n    userId: userIdStr,\r\n  });\r\n\r\n  if (results.length === 0) {\r\n    throw new AppError(\"No relevant content found in your document\", 404);\r\n  }\r\n\r\n  // Format results (already filtered by Pinecone natively)\r\n  return {\r\n    documents: [results.map((r) => r.pageContent)],\r\n    ids: [results.map((r) => r.id || \"\")],\r\n    metadatas: [results.map((r) => r.metadata || {})],\r\n  };\r\n}\r\n"
    }
  },
  "utils": {
    "AppError.js": "export class AppError extends Error {\r\n  constructor(message, statusCode) {\r\n    super(message);\r\n    this.statusCode = statusCode;\r\n    this.status = `${statusCode}`.startsWith(\"4\") ? \"fail\" : \"error\";\r\n    this.isOperational = true;\r\n\r\n    Error.captureStackTrace(this, this.constructor);\r\n  }\r\n}\r\n",
    "logger.js": "import pino from \"pino\";\r\n\r\n/**\r\n * Structured Logger using Pino\r\n * Provides contextual logging with sessionId, socketId, etc.\r\n */\r\n\r\nconst isDevelopment = process.env.NODE_ENV === \"development\";\r\n\r\n// Create logger instance\r\nconst logger = pino({\r\n  level: process.env.LOG_LEVEL || (isDevelopment ? \"debug\" : \"info\"),\r\n  transport: isDevelopment\r\n    ? {\r\n        target: \"pino-pretty\",\r\n        options: {\r\n          colorize: true,\r\n          translateTime: \"SYS:standard\",\r\n          ignore: \"pid,hostname\",\r\n        },\r\n      }\r\n    : undefined,\r\n});\r\n\r\n/**\r\n * Create child logger with context\r\n * @param {Object} context - Context object (sessionId, socketId, userId, etc.)\r\n * @returns {Object} Child logger instance\r\n */\r\nexport function createLogger(context = {}) {\r\n  return logger.child(context);\r\n}\r\n\r\n/**\r\n * Default logger instance\r\n */\r\nexport default logger;\r\n\r\n"
  }
}